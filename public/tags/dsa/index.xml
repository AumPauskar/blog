<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dsa on Aum&#39;s blogging site</title>
    <link>https://aumpauskar.github.io/blog/tags/dsa/</link>
    <description>Recent content in Dsa on Aum&#39;s blogging site</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 30 Dec 2023 22:56:49 +0530</lastBuildDate>
    <atom:link href="https://aumpauskar.github.io/blog/tags/dsa/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leetcode solutions</title>
      <link>https://aumpauskar.github.io/blog/posts/dsa/leetcode/</link>
      <pubDate>Sat, 30 Dec 2023 22:56:49 +0530</pubDate>
      <guid>https://aumpauskar.github.io/blog/posts/dsa/leetcode/</guid>
      <description>Leetcode solutions Problem 1: Two Sum 1 2 3 4 5 6 7 8 9 10 11 12 class Solution(object): def twoSum(self, nums, target): &amp;#34;&amp;#34;&amp;#34; :type nums: List[int] :type target: int :rtype: List[int] &amp;#34;&amp;#34;&amp;#34; for i in range(0, len(nums)): for j in range(0, len(nums)): if nums[i]+nums[j] == target and i!=j: op = [i,j] return op Problem 2: Roman to integer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution(object): def romanToInt(self, s): &amp;#34;&amp;#34;&amp;#34; :type s: str :rtype: int &amp;#34;&amp;#34;&amp;#34; roman = {&amp;#39;I&amp;#39;:1,&amp;#39;V&amp;#39;:5,&amp;#39;X&amp;#39;:10,&amp;#39;L&amp;#39;:50,&amp;#39;C&amp;#39;:100,&amp;#39;D&amp;#39;:500,&amp;#39;M&amp;#39;:1000,&amp;#39;IV&amp;#39;:4,&amp;#39;IX&amp;#39;:9,&amp;#39;XL&amp;#39;:40,&amp;#39;XC&amp;#39;:90,&amp;#39;CD&amp;#39;:400,&amp;#39;CM&amp;#39;:900} i = 0 num = 0 while i &amp;lt; len(s): if i+1&amp;lt;len(s) and s[i:i+2] in roman: num+=roman[s[i:i+2]] i+=2 else: #print(i) num+=roman[s[i]] i+=1 return num Problem 3: Pallindrome 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution(object): def isPalindrome(self, x): &amp;#34;&amp;#34;&amp;#34; :type x: int :rtype: bool &amp;#34;&amp;#34;&amp;#34; if x &amp;lt; 0: return False # Store the number in a variable number = x # This will store the reverse of the number reverse = 0 while number: reverse = reverse * 10 + number % 10 number //= 10 return x == reverse Problem 4: Longest Common Prefix 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution(object): def longestCommonPrefix(self, strs): &amp;#34;&amp;#34;&amp;#34; :type strs: List[str] :rtype: str &amp;#34;&amp;#34;&amp;#34; size = len(strs) # if size is 0, return empty string if (size == 0): return &amp;#34;&amp;#34; if (size == 1): return strs[0] # sort the array of strings strs.</description>
    </item>
    <item>
      <title>Basic DSA algorithms using C</title>
      <link>https://aumpauskar.github.io/blog/posts/dsa/dsabasics/</link>
      <pubDate>Thu, 16 Nov 2023 10:38:34 +0530</pubDate>
      <guid>https://aumpauskar.github.io/blog/posts/dsa/dsabasics/</guid>
      <description>A complete guide ds Termwork 1 - Infix evaluation Algorithm Create an empty stack (operandStack) to store operands and an empty stack (operatorStack) to store operators. Initialize a variable (result) to store the final output Iterate through each character of the infix expression. If the current character is an operand, add it to the operandStack. If the current character is an operator, pop operators from operatorStack and add them to operandStack until an operator with lower precedence is found.</description>
    </item>
  </channel>
</rss>
