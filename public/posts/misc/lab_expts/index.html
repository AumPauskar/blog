<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Lab expriments and termworks | Aum's blogging site</title>
<meta name=keywords content><meta name=description content="Lab expriments and termworks Computer Networks lab Template Title of the experiment Objective of the experiment Brief theory about the experiment Algorithm & Program Sample input/output with calculations if necessary Course Learning Outcome Conclusion References Termwork 1 Title of the experiment Objective of the experiment Brief theory about the experiment Algorithm & Program Sample input/output with calculations if necessary Course Learning Outcome Conclusion References Termwork 2 Title of the experiment Objective of the experiment Brief theory about the experiment Algorithm & Program Sample input/output with calculations if necessary Course Learning Outcome Conclusion References Termwork 3 Title of the experiment Objective of the experiment Brief theory about the experiment Algorithm & Program Sample input/output with calculations if necessary Course Learning Outcome Conclusion References Termwork 4 Title of the experiment Objective of the experiment Brief theory about the experiment Algorithm & Program Sample input/output with calculations if necessary Course Learning Outcome Conclusion References Microcontroller lab Template Title of the experiment Objective of the experiment Brief theory about the experiment including instructions used in that program with proper syntax Program with comments Sample input/output with calculations if necessary Course Learning Outcome Conclusion References Termwork 1a Title of the experiment"><meta name=author content="Aum Pauskar"><link rel=canonical href=https://aumpauskar.github.io/blog/posts/misc/lab_expts/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/blog/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://aumpauskar.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://aumpauskar.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://aumpauskar.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://aumpauskar.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://aumpauskar.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-EV8NVH4QG5"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EV8NVH4QG5",{anonymize_ip:!1})}</script><meta property="og:title" content="Lab expriments and termworks"><meta property="og:description" content="Lab expriments and termworks Computer Networks lab Template Title of the experiment Objective of the experiment Brief theory about the experiment Algorithm & Program Sample input/output with calculations if necessary Course Learning Outcome Conclusion References Termwork 1 Title of the experiment Objective of the experiment Brief theory about the experiment Algorithm & Program Sample input/output with calculations if necessary Course Learning Outcome Conclusion References Termwork 2 Title of the experiment Objective of the experiment Brief theory about the experiment Algorithm & Program Sample input/output with calculations if necessary Course Learning Outcome Conclusion References Termwork 3 Title of the experiment Objective of the experiment Brief theory about the experiment Algorithm & Program Sample input/output with calculations if necessary Course Learning Outcome Conclusion References Termwork 4 Title of the experiment Objective of the experiment Brief theory about the experiment Algorithm & Program Sample input/output with calculations if necessary Course Learning Outcome Conclusion References Microcontroller lab Template Title of the experiment Objective of the experiment Brief theory about the experiment including instructions used in that program with proper syntax Program with comments Sample input/output with calculations if necessary Course Learning Outcome Conclusion References Termwork 1a Title of the experiment"><meta property="og:type" content="article"><meta property="og:url" content="https://aumpauskar.github.io/blog/posts/misc/lab_expts/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-16T17:44:08+05:30"><meta property="article:modified_time" content="2023-12-16T17:44:08+05:30"><meta property="og:site_name" content="Aum's blogging site"><meta name=twitter:card content="summary"><meta name=twitter:title content="Lab expriments and termworks"><meta name=twitter:description content="Lab expriments and termworks Computer Networks lab Template Title of the experiment Objective of the experiment Brief theory about the experiment Algorithm & Program Sample input/output with calculations if necessary Course Learning Outcome Conclusion References Termwork 1 Title of the experiment Objective of the experiment Brief theory about the experiment Algorithm & Program Sample input/output with calculations if necessary Course Learning Outcome Conclusion References Termwork 2 Title of the experiment Objective of the experiment Brief theory about the experiment Algorithm & Program Sample input/output with calculations if necessary Course Learning Outcome Conclusion References Termwork 3 Title of the experiment Objective of the experiment Brief theory about the experiment Algorithm & Program Sample input/output with calculations if necessary Course Learning Outcome Conclusion References Termwork 4 Title of the experiment Objective of the experiment Brief theory about the experiment Algorithm & Program Sample input/output with calculations if necessary Course Learning Outcome Conclusion References Microcontroller lab Template Title of the experiment Objective of the experiment Brief theory about the experiment including instructions used in that program with proper syntax Program with comments Sample input/output with calculations if necessary Course Learning Outcome Conclusion References Termwork 1a Title of the experiment"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://aumpauskar.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"Lab expriments and termworks","item":"https://aumpauskar.github.io/blog/posts/misc/lab_expts/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Lab expriments and termworks","name":"Lab expriments and termworks","description":"Lab expriments and termworks Computer Networks lab Template Title of the experiment Objective of the experiment Brief theory about the experiment Algorithm \u0026amp; Program Sample input/output with calculations if necessary Course Learning Outcome Conclusion References Termwork 1 Title of the experiment Objective of the experiment Brief theory about the experiment Algorithm \u0026amp; Program Sample input/output with calculations if necessary Course Learning Outcome Conclusion References Termwork 2 Title of the experiment Objective of the experiment Brief theory about the experiment Algorithm \u0026amp; Program Sample input/output with calculations if necessary Course Learning Outcome Conclusion References Termwork 3 Title of the experiment Objective of the experiment Brief theory about the experiment Algorithm \u0026amp; Program Sample input/output with calculations if necessary Course Learning Outcome Conclusion References Termwork 4 Title of the experiment Objective of the experiment Brief theory about the experiment Algorithm \u0026amp; Program Sample input/output with calculations if necessary Course Learning Outcome Conclusion References Microcontroller lab Template Title of the experiment Objective of the experiment Brief theory about the experiment including instructions used in that program with proper syntax Program with comments Sample input/output with calculations if necessary Course Learning Outcome Conclusion References Termwork 1a Title of the experiment","keywords":[],"articleBody":"Lab expriments and termworks Computer Networks lab Template Title of the experiment Objective of the experiment Brief theory about the experiment Algorithm \u0026 Program Sample input/output with calculations if necessary Course Learning Outcome Conclusion References Termwork 1 Title of the experiment Objective of the experiment Brief theory about the experiment Algorithm \u0026 Program Sample input/output with calculations if necessary Course Learning Outcome Conclusion References Termwork 2 Title of the experiment Objective of the experiment Brief theory about the experiment Algorithm \u0026 Program Sample input/output with calculations if necessary Course Learning Outcome Conclusion References Termwork 3 Title of the experiment Objective of the experiment Brief theory about the experiment Algorithm \u0026 Program Sample input/output with calculations if necessary Course Learning Outcome Conclusion References Termwork 4 Title of the experiment Objective of the experiment Brief theory about the experiment Algorithm \u0026 Program Sample input/output with calculations if necessary Course Learning Outcome Conclusion References Microcontroller lab Template Title of the experiment Objective of the experiment Brief theory about the experiment including instructions used in that program with proper syntax Program with comments Sample input/output with calculations if necessary Course Learning Outcome Conclusion References Termwork 1a Title of the experiment\nObserve the contents of the resister\nObjective of the experiment To observe the contents of the resister and to understand the basic concepts of ARM assembly language programming\nBrief theory about the experiment including instructions used in that program with proper syntax\nARM Assembly language is a low-level programming language used for programming ARM processors. It provides direct access to the processor’s features and allows precise control over the processor’s behavior.\nHere’s a brief description of the ARM Assembly instructions and directives you’ve asked about:\nAREA: This directive is used to define a block of code or data. The syntax is AREA name, type, options. The name is a label that identifies the area. The type can be CODE (for code areas) or DATA (for data areas). The options can include READONLY (the area cannot be written to), ALIGN=n (align the area to a 2^n byte boundary), and others. ONE, CODE, READONLY: In your code, ONE is the name of the area, CODE indicates that this area contains code, and READONLY means that this area cannot be written to. MOV: This instruction copies a value into a register. The syntax is MOV Rd, Operand2. Rd is the destination register, and Operand2 is the value to be copied. ADD: This instruction adds two values and stores the result in a register. The syntax is ADD Rd, Rn, Operand2. Rd is the destination register, Rn is the first operand, and Operand2 is the second operand. L BL: BL is a branch instruction that calls a subroutine. The L label is the target of the branch. The BL instruction also stores the return address in the link register (LR). END: This directive marks the end of the assembly file. It’s not required in all assemblers, but it’s good practice to include it. Program with comments\n1 2 3 4 5 6 7 8 AREA ONE, CODE, READONLY ENTRY MOV R0, #0X01 MOV R1, #0X02 ADD R2, R1, R0 L\tB L END Sample input/output with calculations if necessary\nCourse Learning Outcome\nUnderstand the basic concepts of ARM assembly language Understand the basic concepts of ARM assembly language programming Conclusion\nIn conclusion, the ARM assembly program efficiently adds two numbers and stores the result in a register. The code demonstrates key concepts such as register manipulation, memory access, and conditional branching.\nReferences\nAndrew N Sloss, Dominic Symes and Chris Wright, ARM system developers guide, Elsevier, Morgan Kaufman publishers, 2008. Shibu K V, “Introduction to Embedded Systems”, Tata McGraw Hill Education, Private Limited, 2nd Edition. Termwork 1b Title of the experiment\nDevelop an assembly language program to transfer a block of data from source to destination.\nObjective of the experiment\nTo implement an assembly language program to transfer a block of data from source to destination and to understand the basic concepts of ARM assembly language programming for data processing\nBrief theory about the experiment including instructions used in that program with proper syntax\nIn ARM programming, memory is organized into blocks that can be accessed by the processor. Each block has a unique address. The processor can read data from a memory block (load) or write data to a memory block (store).\nLOOP: This is a label that marks the start of a loop. The BNE instruction later in the code branches back to this label to repeat the loop. LDRH: This instruction loads a halfword (2 bytes) from memory into a register. The syntax is LDRH Rd, [Rn], #offset. Rd is the destination register, Rn is the base register, and offset is the number of bytes to increment Rn after the load. STRH: This instruction stores a halfword (2 bytes) from a register to memory. The syntax is STRH Rd, [Rn], #offset. Rd is the source register, Rn is the base register, and offset is the number of bytes to increment Rn after the store. SUBS: This instruction subtracts a value from a register and updates the condition flags. The syntax is SUBS Rd, Rn, #immediate. Rd is the destination register, Rn is the first operand, and immediate is the value to subtract. BNE: This instruction branches to a label if the Zero flag is not set (i.e., the last comparison or arithmetic operation did not result in zero). The syntax is BNE label. FBLOCK: This is a label that marks the start of a memory block. The DCW directive following this label defines the contents of the block. DCW: This directive defines a constant word (4 bytes) in memory. The syntax is DCW value. You can specify multiple values, separated by commas. SBLOCK: This is another label that marks the start of a memory block. The DCW directive following this label defines the contents of the block. Program with comments\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 AREA ONE, CODE, READONLY ENTRY MOV R5, #10 LDR R0, =FBLOCK ; Load the address of FBLOCK into R0 LDR R2, =SBLOCK ; Load the address of SBLOCK into R2 LOOP\tLDRH R1, [R0], #2 ; Load 2 bytes from the source (increment R0 by 2) STRH R1, [R2], #2 ; Store 2 bytes to the destination (increment R2 by 2) SUBS R5, R5, #1 ; Subtract 1 from R5 BNE LOOP ; Branch back to LOOP if R5 is not zero L\tB L ; Infinite loop (useful for preventing the program from falling through) FBLOCK DCW 0X1234, 0X5678, 0x2652, 0x1124 AREA MYDATA, DATA, READWRITE SBLOCK DCW 0 Sample input/output with calculations if necessary\nCourse Learning Outcome\nUnderstand the basic concepts of loops in ARM assembly language Understanding the basic concepts of ARM assembly language programming for data processing Understanding the concepts of FBLOCK and SBLOCK in ARM assembly language programming for data processing Conclusion\nIn conclusion, the ARM assembly program efficiently transfers a block of data from source to destination using a loop-based approach. The code demonstrates key concepts such as register manipulation, memory access, and conditional branching.\nReferences\nAndrew N Sloss, Dominic Symes and Chris Wright, ARM system developers guide, Elsevier, Morgan Kaufman publishers, 2008. Shibu K V, “Introduction to Embedded Systems”, Tata McGraw Hill Education, Private Limited, 2nd Edition. Termwork 2 Title of the experiment\nWrite an assembly program to add 16 bit numbers and store the result in internal RAM\nObjective of the experiment\nTo implement an assembly program to add 16 bit numbers and store the result in internal RAM and to understand the basic concepts of ARM assembly language programming for data processing\nBrief theory about the experiment including instructions used in that program with proper syntax\nThis ARM Assembly code performs the sum of a series of half-word (16-bit) values stored in memory and stores the result in another memory location.\nLDR R1, =FBLOCK: This line loads the address of the FBLOCK memory area into register R1.\nLDR R2, =RESULT: This line loads the address of the RESULT memory area into register R2\nLOOP LDRH R3, [R1], #2: This line starts a loop. It loads a half-word value from the memory address in R1 into register R3, then increments R1 by 2 (to point to the next half-word).\nADD R4, R4, R3: This line adds the value in R3 to the value in R4, storing the result back in R4.\nBNE LOOP: If the value in R0 is not zero (i.e., the loop is not finished), this line branches back to the LOOP label.\nFBLOCK DCW 0X1111, 0X2222, 0X3333, 0X4444, 0X5555, 0X6666, 0X7777: This line defines a block of memory with the specified half-word values.\nRESULT DCD 0: This line defines a word in memory with the initial value 0. This is where the result of the sum is stored.\nProgram with comments\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 AREA THREE, CODE, READONLY ENTRY MOV R0, #10 MOV R4, #0000 LDR R1, =FBLOCK LDR R2, =RESULT LOOP\tLDRH R3, [R1], #2 ; Use LDRH to load a half-word (16-bit) value ADD R4, R4, R3 STR R4, [R2], #4 ; Use post-indexed addressing mode to store the result SUBS R0, #1 BNE LOOP L\tB L FBLOCK DCW 0X1111, 0X2222, 0X3333, 0X4444, 0X5555, 0X6666, 0X7777 AREA MYDATA, DATA, READWRITE RESULT DCD 0 END Sample input/output with calculations if necessary\nCourse Learning Outcome\nUnderstand various addressing modes in ARM assembly language Understand LDRH instruction in ARM assembly language programming for data processing Understand the concepts of FBLOCK and SBLOCK in ARM assembly language programming for data processing Conclusion\nIn conclusion, the ARM assembly program efficiently adds a series of half-word values and stores the result in a memory location. The code demonstrates key concepts such as register manipulation, memory access, and conditional branching.\nReferences\nAndrew N Sloss, Dominic Symes and Chris Wright, ARM system developers guide, Elsevier, Morgan Kaufman publishers, 2008. Shibu K V, “Introduction to Embedded Systems”, Tata McGraw Hill Education, Private Limited, 2nd Edition. Termwork 3 Title of the experiment\nFind the factorial of a number and store the result in internal RAM\nObjective of the experiment\nTo implement an assembly language program to find the factorial of a number and store the result in internal RAM\nBrief theory about the experiment including instructions used in that program with proper syntax\nIn the provided ARM Assembly code, the factorial of a number is calculated using a loop. The loop starts with the number (in this case, 5) and multiplies it with the result of the previous multiplication (initially set to 1). The number is then decremented by 1, and the process repeats until the number reaches 0.\nHere’s a brief description of the MUL instruction in ARM Assembly:\nMUL: This instruction multiplies two registers and stores the result in a third register. The syntax is MUL Rd, Rm, Rs. Rd is the destination register, Rm is the first operand (multiplicand), and Rs is the second operand (multiplier). In the provided code, MUL R3, R2, R1 multiplies the contents of R2 and R1 and stores the result in R3. Program with comments\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 AREA ONE, CODE, READONLY ENTRY MOV R1, #5\t; Set the initial value for the factorial MOV R2, #1\t; Initialize the result to 1 L\tMUL R3, R2, R1 ; Multiply the result by the current value of R1 and store in R3 MOV R2, R3 ; Move the result from R3 to R2 SUBS R1, R1, #1 ; Decrement R1 BNE L ; Branch back to L if R1 is not zero ; At this point, R2 contains the factorial result ; You can use R2 or store the result in another register/memory location END Sample input/output with calculations if necessary\nCourse Learning Outcome\nUnderstanding the MUL intruction in ARM assembly language programming for data processing Understanding the concepts of looping in ARM assembly language programming for data processing Conclusion\nIn conclusion, the ARM assembly program efficiently calculates the factorial of a number using a loop-based approach. The code demonstrates key concepts such as register manipulation, memory access, and conditional branching.\nReferences\nAndrew N Sloss, Dominic Symes and Chris Wright, ARM system developers guide, Elsevier, Morgan Kaufman publishers, 2008. Shibu K V, “Introduction to Embedded Systems”, Tata McGraw Hill Education, Private Limited, 2nd Edition. Termwork 4 Title of the experiment\nWrite an assembly language program to find the largetst number in an array of 32 bit numbers amd store the result in internal RAM\nObjective of the experiment\nTo implement an assembly language program to find the largetst number in an array of 32 bit numbers amd store the result in internal RAM\nBrief theory about the experiment including instructions used in that program with proper syntax\nIn ARM programming, memory is organized into blocks that can be accessed by the processor. Each block has a unique address. The processor can read data from a memory block (load) or write data to a memory block (store).\nThe CMP instruction in ARM Assembly compares two values and sets the condition flags based on the result. These flags can then be used by subsequent branch instructions to control the flow of the program.\nHere’s a brief description of the ARM Assembly instructions and directives in your code:\nLDR: This instruction loads a word (4 bytes) from memory into a register. The syntax is LDR Rd, [Rn], #offset. Rd is the destination register, Rn is the base register, and offset is the number of bytes to increment Rn after the load. CMP: This instruction compares two registers and sets the condition flags based on the result. The syntax is CMP Rn, Operand2. Rn is the first operand, and Operand2 is the second operand. BHI: This instruction branches to a label if the last comparison resulted in a higher value (unsigned). The syntax is BHI label. DCD: This directive defines a constant doubleword (8 bytes) in memory. The syntax is DCD value. You can specify multiple values, separated by commas. Program with comments\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 AREA ONE, CODE, READONLY ENTRY MOV R5, #6 LDR R1, =VALUE1 LDR R2, [R1], #4 LOOP LDR R4, [R1], #4 CMP R2, R4 BHI LOOP1 MOV R2, R4 LOOP1 SUBS R5, #1 BNE LOOP LDR R6, =RESULT STR R2, [R6] L\tB L VALUE1 DCD 0X44444444, 0X22222222, 0X11111111, 0X22222222, 0XAAAAAAAA, 0X88888888, 0X99999999 AREA DATA2, DATA, READWRITE RESULT DCD 0 END Sample input/output with calculations if necessary\nCourse Learning Outcome\nUnderstand the basic concepts of ARM assembly language Understand the basic concepts of ARM assembly language programming Understand the basic concepts of ARM assembly language programming for data processing Understand the basic concepts of ARM assembly language programming for data processing using arrays Conclusion\nIn conclusion, the ARM assembly program efficiently finds the maximum value in an array using a loop-based approach. The code demonstrates key concepts such as register manipulation, memory access, and conditional branching.\nReferences\nAndrew N Sloss, Dominic Symes and Chris Wright, ARM system developers guide, Elsevier, Morgan Kaufman publishers, 2008. Shibu K V, “Introduction to Embedded Systems”, Tata McGraw Hill Education, Private Limited, 2nd Edition. ","wordCount":"2563","inLanguage":"en","datePublished":"2023-12-16T17:44:08+05:30","dateModified":"2023-12-16T17:44:08+05:30","author":{"@type":"Person","name":"Aum Pauskar"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://aumpauskar.github.io/blog/posts/misc/lab_expts/"},"publisher":{"@type":"Organization","name":"Aum's blogging site","logo":{"@type":"ImageObject","url":"https://aumpauskar.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://aumpauskar.github.io/blog/ accesskey=h title="Aum's blogging site (Alt + H)">Aum's blogging site</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://aumpauskar.github.io/blog/>Home</a>&nbsp;»&nbsp;<a href=https://aumpauskar.github.io/blog/posts/>Posts</a></div><h1 class=post-title>Lab expriments and termworks</h1><div class=post-meta><span title='2023-12-16 17:44:08 +0530 IST'>December 16, 2023</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;2563 words&nbsp;·&nbsp;Aum Pauskar</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#computer-networks-lab>Computer Networks lab</a><ul><li><a href=#template>Template</a></li><li><a href=#termwork-1>Termwork 1</a></li><li><a href=#termwork-2>Termwork 2</a></li><li><a href=#termwork-3>Termwork 3</a></li><li><a href=#termwork-4>Termwork 4</a></li></ul></li><li><a href=#microcontroller-lab>Microcontroller lab</a><ul><li><a href=#template-1>Template</a></li><li><a href=#termwork-1a>Termwork 1a</a></li><li><a href=#termwork-1b>Termwork 1b</a></li><li><a href=#termwork-2-1>Termwork 2</a></li><li><a href=#termwork-3-1>Termwork 3</a></li><li><a href=#termwork-4-1>Termwork 4</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h1 id=lab-expriments-and-termworks>Lab expriments and termworks<a hidden class=anchor aria-hidden=true href=#lab-expriments-and-termworks>#</a></h1><h2 id=computer-networks-lab>Computer Networks lab<a hidden class=anchor aria-hidden=true href=#computer-networks-lab>#</a></h2><h3 id=template>Template<a hidden class=anchor aria-hidden=true href=#template>#</a></h3><ol><li>Title of the experiment</li><li>Objective of the experiment</li><li>Brief theory about the experiment</li><li>Algorithm & Program</li><li>Sample input/output with calculations if necessary</li><li>Course Learning Outcome</li><li>Conclusion</li><li>References</li></ol><h3 id=termwork-1>Termwork 1<a hidden class=anchor aria-hidden=true href=#termwork-1>#</a></h3><ul><li>Title of the experiment</li><li>Objective of the experiment</li><li>Brief theory about the experiment</li><li>Algorithm & Program</li><li>Sample input/output with calculations if necessary</li><li>Course Learning Outcome</li><li>Conclusion</li><li>References</li></ul><h3 id=termwork-2>Termwork 2<a hidden class=anchor aria-hidden=true href=#termwork-2>#</a></h3><ul><li>Title of the experiment</li><li>Objective of the experiment</li><li>Brief theory about the experiment</li><li>Algorithm & Program</li><li>Sample input/output with calculations if necessary</li><li>Course Learning Outcome</li><li>Conclusion</li><li>References</li></ul><h3 id=termwork-3>Termwork 3<a hidden class=anchor aria-hidden=true href=#termwork-3>#</a></h3><ul><li>Title of the experiment</li><li>Objective of the experiment</li><li>Brief theory about the experiment</li><li>Algorithm & Program</li><li>Sample input/output with calculations if necessary</li><li>Course Learning Outcome</li><li>Conclusion</li><li>References</li></ul><h3 id=termwork-4>Termwork 4<a hidden class=anchor aria-hidden=true href=#termwork-4>#</a></h3><ul><li>Title of the experiment</li><li>Objective of the experiment</li><li>Brief theory about the experiment</li><li>Algorithm & Program</li><li>Sample input/output with calculations if necessary</li><li>Course Learning Outcome</li><li>Conclusion</li><li>References</li></ul><h2 id=microcontroller-lab>Microcontroller lab<a hidden class=anchor aria-hidden=true href=#microcontroller-lab>#</a></h2><h3 id=template-1>Template<a hidden class=anchor aria-hidden=true href=#template-1>#</a></h3><ol><li>Title of the experiment</li><li>Objective of the experiment</li><li>Brief theory about the experiment including instructions used in that program with proper syntax</li><li>Program with comments</li><li>Sample input/output with calculations if necessary</li><li>Course Learning Outcome</li><li>Conclusion</li><li>References</li></ol><h3 id=termwork-1a>Termwork 1a<a hidden class=anchor aria-hidden=true href=#termwork-1a>#</a></h3><ul><li><p>Title of the experiment<br>Observe the contents of the resister</p></li><li><p>Objective of the experiment
To observe the contents of the resister and to understand the basic concepts of ARM assembly language programming</p></li><li><p>Brief theory about the experiment including instructions used in that program with proper syntax</p><p>ARM Assembly language is a low-level programming language used for programming ARM processors. It provides direct access to the processor&rsquo;s features and allows precise control over the processor&rsquo;s behavior.</p><p>Here&rsquo;s a brief description of the ARM Assembly instructions and directives you&rsquo;ve asked about:</p><ul><li><code>AREA</code>: This directive is used to define a block of code or data. The syntax is AREA name, type, options. The name is a label that identifies the area. The type can be CODE (for code areas) or DATA (for data areas). The options can include READONLY (the area cannot be written to), ALIGN=n (align the area to a 2^n byte boundary), and others.</li><li><code>ONE</code>, <code>CODE</code>, <code>READONLY</code>: In your code, ONE is the name of the area, CODE indicates that this area contains code, and READONLY means that this area cannot be written to.</li><li><code>MOV</code>: This instruction copies a value into a register. The syntax is MOV Rd, Operand2. Rd is the destination register, and Operand2 is the value to be copied.</li><li><code>ADD</code>: This instruction adds two values and stores the result in a register. The syntax is ADD Rd, Rn, Operand2. Rd is the destination register, Rn is the first operand, and Operand2 is the second operand.</li><li><code>L BL</code>: BL is a branch instruction that calls a subroutine. The L label is the target of the branch. The BL instruction also stores the return address in the link register (LR).</li><li><code>END</code>: This directive marks the end of the assembly file. It&rsquo;s not required in all assemblers, but it&rsquo;s good practice to include it.</li></ul></li><li><p>Program with comments</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5>5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6>6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7>7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl>	<span class=nf>AREA</span> <span class=no>ONE</span><span class=p>,</span> <span class=no>CODE</span><span class=p>,</span> <span class=no>READONLY</span>
</span></span><span class=line><span class=cl>	<span class=nf>ENTRY</span>
</span></span><span class=line><span class=cl>	<span class=nf>MOV</span> <span class=no>R0</span><span class=p>,</span> <span class=c1>#0X01
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>MOV</span> <span class=no>R1</span><span class=p>,</span> <span class=c1>#0X02
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>ADD</span> <span class=no>R2</span><span class=p>,</span> <span class=no>R1</span><span class=p>,</span> <span class=no>R0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>L</span>	<span class=no>B</span> <span class=no>L</span>
</span></span><span class=line><span class=cl>	<span class=nf>END</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>Sample input/output with calculations if necessary</p></li><li><p>Course Learning Outcome</p><ul><li>Understand the basic concepts of ARM assembly language</li><li>Understand the basic concepts of ARM assembly language programming</li></ul></li><li><p>Conclusion<br>In conclusion, the ARM assembly program efficiently adds two numbers and stores the result in a register. The code demonstrates key concepts such as register manipulation, memory access, and conditional branching.</p></li><li><p>References</p></li></ul><ol><li>Andrew N Sloss, Dominic Symes and Chris Wright, ARM system developers guide, Elsevier,
Morgan Kaufman publishers, 2008.</li><li>Shibu K V, “Introduction to Embedded Systems”, Tata McGraw Hill Education, Private Limited, 2nd Edition.</li></ol><h3 id=termwork-1b>Termwork 1b<a hidden class=anchor aria-hidden=true href=#termwork-1b>#</a></h3><ul><li><p>Title of the experiment<br>Develop an assembly language program to transfer a block of data from source to destination.</p></li><li><p>Objective of the experiment<br>To implement an assembly language program to transfer a block of data from source to destination and to understand the basic concepts of ARM assembly language programming for data processing</p></li><li><p>Brief theory about the experiment including instructions used in that program with proper syntax</p><p>In ARM programming, memory is organized into blocks that can be accessed by the processor. Each block has a unique address. The processor can read data from a memory block (load) or write data to a memory block (store).</p><ul><li><code>LOOP</code>: This is a label that marks the start of a loop. The BNE instruction later in the code branches back to this label to repeat the loop.</li><li><code>LDRH</code>: This instruction loads a halfword (2 bytes) from memory into a register. The syntax is LDRH Rd, [Rn], #offset. Rd is the destination register, Rn is the base register, and offset is the number of bytes to increment Rn after the load.</li><li><code>STRH</code>: This instruction stores a halfword (2 bytes) from a register to memory. The syntax is STRH Rd, [Rn], #offset. Rd is the source register, Rn is the base register, and offset is the number of bytes to increment Rn after the store.</li><li><code>SUBS</code>: This instruction subtracts a value from a register and updates the condition flags. The syntax is SUBS Rd, Rn, #immediate. Rd is the destination register, Rn is the first operand, and immediate is the value to subtract.</li><li><code>BNE</code>: This instruction branches to a label if the Zero flag is not set (i.e., the last comparison or arithmetic operation did not result in zero). The syntax is BNE label.</li><li><code>FBLOCK</code>: This is a label that marks the start of a memory block. The DCW directive following this label defines the contents of the block.</li><li><code>DCW</code>: This directive defines a constant word (4 bytes) in memory. The syntax is DCW value. You can specify multiple values, separated by commas.</li><li><code>SBLOCK</code>: This is another label that marks the start of a memory block. The DCW directive following this label defines the contents of the block.</li></ul></li><li><p>Program with comments</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl>	<span class=nf>AREA</span> <span class=no>ONE</span><span class=p>,</span> <span class=no>CODE</span><span class=p>,</span> <span class=no>READONLY</span>
</span></span><span class=line><span class=cl>		<span class=nf>ENTRY</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=nf>MOV</span> <span class=no>R5</span><span class=p>,</span> <span class=c1>#10
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>LDR</span> <span class=no>R0</span><span class=p>,</span> <span class=err>=</span><span class=no>FBLOCK</span>   <span class=c1>; Load the address of FBLOCK into R0
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>LDR</span> <span class=no>R2</span><span class=p>,</span> <span class=err>=</span><span class=no>SBLOCK</span>   <span class=c1>; Load the address of SBLOCK into R2
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nf>LOOP</span>	<span class=no>LDRH</span> <span class=no>R1</span><span class=p>,</span> <span class=p>[</span><span class=no>R0</span><span class=p>],</span> <span class=c1>#2  ; Load 2 bytes from the source (increment R0 by 2)
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>STRH</span> <span class=no>R1</span><span class=p>,</span> <span class=p>[</span><span class=no>R2</span><span class=p>],</span> <span class=c1>#2  ; Store 2 bytes to the destination (increment R2 by 2)
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>SUBS</span> <span class=no>R5</span><span class=p>,</span> <span class=no>R5</span><span class=p>,</span> <span class=c1>#1    ; Subtract 1 from R5
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>BNE</span> <span class=no>LOOP</span>           <span class=c1>; Branch back to LOOP if R5 is not zero
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nf>L</span>		<span class=no>B</span> <span class=no>L</span>                <span class=c1>; Infinite loop (useful for preventing the program from falling through)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nf>FBLOCK</span> <span class=no>DCW</span> <span class=mi>0X1234</span><span class=p>,</span> <span class=mi>0X5678</span><span class=p>,</span> <span class=mi>0x2652</span><span class=p>,</span> <span class=mi>0x1124</span>
</span></span><span class=line><span class=cl>	<span class=nf>AREA</span> <span class=no>MYDATA</span><span class=p>,</span> <span class=no>DATA</span><span class=p>,</span> <span class=no>READWRITE</span>
</span></span><span class=line><span class=cl><span class=nf>SBLOCK</span> <span class=no>DCW</span> <span class=mi>0</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>Sample input/output with calculations if necessary</p></li><li><p>Course Learning Outcome</p><ul><li>Understand the basic concepts of loops in ARM assembly language</li><li>Understanding the basic concepts of ARM assembly language programming for data processing</li><li>Understanding the concepts of FBLOCK and SBLOCK in ARM assembly language programming for data processing</li></ul></li><li><p>Conclusion<br>In conclusion, the ARM assembly program efficiently transfers a block of data from source to destination using a loop-based approach. The code demonstrates key concepts such as register manipulation, memory access, and conditional branching.</p></li><li><p>References</p></li></ul><ol><li>Andrew N Sloss, Dominic Symes and Chris Wright, ARM system developers guide, Elsevier,
Morgan Kaufman publishers, 2008.</li><li>Shibu K V, “Introduction to Embedded Systems”, Tata McGraw Hill Education, Private Limited, 2nd Edition.</li></ol><h3 id=termwork-2-1>Termwork 2<a hidden class=anchor aria-hidden=true href=#termwork-2-1>#</a></h3><ul><li><p>Title of the experiment<br>Write an assembly program to add 16 bit numbers and store the result in internal RAM</p></li><li><p>Objective of the experiment<br>To implement an assembly program to add 16 bit numbers and store the result in internal RAM and to understand the basic concepts of ARM assembly language programming for data processing</p></li><li><p>Brief theory about the experiment including instructions used in that program with proper syntax<br>This ARM Assembly code performs the sum of a series of half-word (16-bit) values stored in memory and stores the result in another memory location.</p></li><li><p>LDR R1, =FBLOCK: This line loads the address of the FBLOCK memory area into register R1.</p></li><li><p>LDR R2, =RESULT: This line loads the address of the RESULT memory area into register R2</p></li><li><p>LOOP LDRH R3, [R1], #2: This line starts a loop. It loads a half-word value from the memory address in R1 into register R3, then increments R1 by 2 (to point to the next half-word).</p></li><li><p>ADD R4, R4, R3: This line adds the value in R3 to the value in R4, storing the result back in R4.</p></li><li><p>BNE LOOP: If the value in R0 is not zero (i.e., the loop is not finished), this line branches back to the LOOP label.</p></li><li><p>FBLOCK DCW 0X1111, 0X2222, 0X3333, 0X4444, 0X5555, 0X6666, 0X7777: This line defines a block of memory with the specified half-word values.</p></li><li><p>RESULT DCD 0: This line defines a word in memory with the initial value 0. This is where the result of the sum is stored.</p></li><li><p>Program with comments</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl>	<span class=nf>AREA</span> <span class=no>THREE</span><span class=p>,</span> <span class=no>CODE</span><span class=p>,</span> <span class=no>READONLY</span>
</span></span><span class=line><span class=cl><span class=nf>ENTRY</span>
</span></span><span class=line><span class=cl>			<span class=nf>MOV</span> <span class=no>R0</span><span class=p>,</span> <span class=c1>#10
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nf>MOV</span> <span class=no>R4</span><span class=p>,</span> <span class=c1>#0000
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nf>LDR</span> <span class=no>R1</span><span class=p>,</span> <span class=err>=</span><span class=no>FBLOCK</span>
</span></span><span class=line><span class=cl>			<span class=nf>LDR</span> <span class=no>R2</span><span class=p>,</span> <span class=err>=</span><span class=no>RESULT</span>
</span></span><span class=line><span class=cl><span class=nf>LOOP</span>	<span class=no>LDRH</span> <span class=no>R3</span><span class=p>,</span> <span class=p>[</span><span class=no>R1</span><span class=p>],</span> <span class=c1>#2 ; Use LDRH to load a half-word (16-bit) value
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nf>ADD</span> <span class=no>R4</span><span class=p>,</span> <span class=no>R4</span><span class=p>,</span> <span class=no>R3</span>
</span></span><span class=line><span class=cl>			<span class=nf>STR</span> <span class=no>R4</span><span class=p>,</span> <span class=p>[</span><span class=no>R2</span><span class=p>],</span> <span class=c1>#4 ; Use post-indexed addressing mode to store the result
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nf>SUBS</span> <span class=no>R0</span><span class=p>,</span> <span class=c1>#1
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nf>BNE</span> <span class=no>LOOP</span>
</span></span><span class=line><span class=cl><span class=nf>L</span>			<span class=no>B</span> <span class=no>L</span>
</span></span><span class=line><span class=cl><span class=nf>FBLOCK</span> <span class=no>DCW</span> <span class=mi>0X1111</span><span class=p>,</span> <span class=mi>0X2222</span><span class=p>,</span> <span class=mi>0X3333</span><span class=p>,</span> <span class=mi>0X4444</span><span class=p>,</span> <span class=mi>0X5555</span><span class=p>,</span> <span class=mi>0X6666</span><span class=p>,</span> <span class=mi>0X7777</span>
</span></span><span class=line><span class=cl>			<span class=nf>AREA</span> <span class=no>MYDATA</span><span class=p>,</span> <span class=no>DATA</span><span class=p>,</span> <span class=no>READWRITE</span>
</span></span><span class=line><span class=cl><span class=nf>RESULT</span> <span class=no>DCD</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=nf>END</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>Sample input/output with calculations if necessary</p></li><li><p>Course Learning Outcome</p><ul><li>Understand various addressing modes in ARM assembly language</li><li>Understand LDRH instruction in ARM assembly language programming for data processing</li><li>Understand the concepts of FBLOCK and SBLOCK in ARM assembly language programming for data processing</li></ul></li><li><p>Conclusion<br>In conclusion, the ARM assembly program efficiently adds a series of half-word values and stores the result in a memory location. The code demonstrates key concepts such as register manipulation, memory access, and conditional branching.</p></li><li><p>References</p></li></ul><ol><li>Andrew N Sloss, Dominic Symes and Chris Wright, ARM system developers guide, Elsevier,
Morgan Kaufman publishers, 2008.</li><li>Shibu K V, “Introduction to Embedded Systems”, Tata McGraw Hill Education, Private Limited, 2nd Edition.</li></ol><h3 id=termwork-3-1>Termwork 3<a hidden class=anchor aria-hidden=true href=#termwork-3-1>#</a></h3><ul><li><p>Title of the experiment<br>Find the factorial of a number and store the result in internal RAM</p></li><li><p>Objective of the experiment<br>To implement an assembly language program to find the factorial of a number and store the result in internal RAM</p></li><li><p>Brief theory about the experiment including instructions used in that program with proper syntax</p><p>In the provided ARM Assembly code, the factorial of a number is calculated using a loop. The loop starts with the number (in this case, 5) and multiplies it with the result of the previous multiplication (initially set to 1). The number is then decremented by 1, and the process repeats until the number reaches 0.</p><p>Here&rsquo;s a brief description of the MUL instruction in ARM Assembly:</p><ul><li><code>MUL</code>: This instruction multiplies two registers and stores the result in a third register. The syntax is MUL Rd, Rm, Rs. Rd is the destination register, Rm is the first operand (multiplicand), and Rs is the second operand (multiplier). In the provided code, MUL R3, R2, R1 multiplies the contents of R2 and R1 and stores the result in R3.</li></ul></li><li><p>Program with comments</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span><span class=lnt id=hl-3-15><a class=lnlinks href=#hl-3-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl>	<span class=nf>AREA</span> <span class=no>ONE</span><span class=p>,</span> <span class=no>CODE</span><span class=p>,</span> <span class=no>READONLY</span>
</span></span><span class=line><span class=cl>	<span class=nf>ENTRY</span>
</span></span><span class=line><span class=cl>		<span class=nf>MOV</span> <span class=no>R1</span><span class=p>,</span> <span class=c1>#5	; Set the initial value for the factorial
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>MOV</span> <span class=no>R2</span><span class=p>,</span> <span class=c1>#1	; Initialize the result to 1
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nf>L</span>		<span class=no>MUL</span> <span class=no>R3</span><span class=p>,</span> <span class=no>R2</span><span class=p>,</span> <span class=no>R1</span> <span class=c1>; Multiply the result by the current value of R1 and store in R3
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>MOV</span> <span class=no>R2</span><span class=p>,</span> <span class=no>R3</span>      <span class=c1>; Move the result from R3 to R2
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>SUBS</span> <span class=no>R1</span><span class=p>,</span> <span class=no>R1</span><span class=p>,</span> <span class=c1>#1 ; Decrement R1
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>BNE</span> <span class=no>L</span>           <span class=c1>; Branch back to L if R1 is not zero
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>		<span class=c1>; At this point, R2 contains the factorial result
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>		<span class=c1>; You can use R2 or store the result in another register/memory location
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=nf>END</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>Sample input/output with calculations if necessary</p></li><li><p>Course Learning Outcome</p><ul><li>Understanding the MUL intruction in ARM assembly language programming for data processing</li><li>Understanding the concepts of looping in ARM assembly language programming for data processing</li></ul></li><li><p>Conclusion<br>In conclusion, the ARM assembly program efficiently calculates the factorial of a number using a loop-based approach. The code demonstrates key concepts such as register manipulation, memory access, and conditional branching.</p></li><li><p>References</p></li></ul><ol><li>Andrew N Sloss, Dominic Symes and Chris Wright, ARM system developers guide, Elsevier,
Morgan Kaufman publishers, 2008.</li><li>Shibu K V, “Introduction to Embedded Systems”, Tata McGraw Hill Education, Private Limited, 2nd Edition.</li></ol><h3 id=termwork-4-1>Termwork 4<a hidden class=anchor aria-hidden=true href=#termwork-4-1>#</a></h3><ul><li><p>Title of the experiment<br>Write an assembly language program to find the largetst number in an array of 32 bit numbers amd store the result in internal RAM</p></li><li><p>Objective of the experiment<br>To implement an assembly language program to find the largetst number in an array of 32 bit numbers amd store the result in internal RAM</p></li><li><p>Brief theory about the experiment including instructions used in that program with proper syntax<br>In ARM programming, memory is organized into blocks that can be accessed by the processor. Each block has a unique address. The processor can read data from a memory block (load) or write data to a memory block (store).</p><p>The CMP instruction in ARM Assembly compares two values and sets the condition flags based on the result. These flags can then be used by subsequent branch instructions to control the flow of the program.</p><p>Here&rsquo;s a brief description of the ARM Assembly instructions and directives in your code:</p><ul><li><code>LDR</code>: This instruction loads a word (4 bytes) from memory into a register. The syntax is LDR Rd, [Rn], #offset. Rd is the destination register, Rn is the base register, and offset is the number of bytes to increment Rn after the load.</li><li><code>CMP</code>: This instruction compares two registers and sets the condition flags based on the result. The syntax is CMP Rn, Operand2. Rn is the first operand, and Operand2 is the second operand.</li><li><code>BHI</code>: This instruction branches to a label if the last comparison resulted in a higher value (unsigned). The syntax is BHI label.</li><li><code>DCD</code>: This directive defines a constant doubleword (8 bytes) in memory. The syntax is DCD value. You can specify multiple values, separated by commas.</li></ul></li><li><p>Program with comments</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span><span class=lnt id=hl-4-14><a class=lnlinks href=#hl-4-14>14</a>
</span><span class=lnt id=hl-4-15><a class=lnlinks href=#hl-4-15>15</a>
</span><span class=lnt id=hl-4-16><a class=lnlinks href=#hl-4-16>16</a>
</span><span class=lnt id=hl-4-17><a class=lnlinks href=#hl-4-17>17</a>
</span><span class=lnt id=hl-4-18><a class=lnlinks href=#hl-4-18>18</a>
</span><span class=lnt id=hl-4-19><a class=lnlinks href=#hl-4-19>19</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl>	<span class=nf>AREA</span> <span class=no>ONE</span><span class=p>,</span> <span class=no>CODE</span><span class=p>,</span> <span class=no>READONLY</span>
</span></span><span class=line><span class=cl>		<span class=nf>ENTRY</span>
</span></span><span class=line><span class=cl>			<span class=nf>MOV</span> <span class=no>R5</span><span class=p>,</span> <span class=c1>#6
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nf>LDR</span> <span class=no>R1</span><span class=p>,</span> <span class=err>=</span><span class=no>VALUE1</span>
</span></span><span class=line><span class=cl>			<span class=nf>LDR</span> <span class=no>R2</span><span class=p>,</span> <span class=p>[</span><span class=no>R1</span><span class=p>],</span> <span class=c1>#4
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>LOOP</span>
</span></span><span class=line><span class=cl>			<span class=nf>LDR</span> <span class=no>R4</span><span class=p>,</span> <span class=p>[</span><span class=no>R1</span><span class=p>],</span> <span class=c1>#4
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nf>CMP</span> <span class=no>R2</span><span class=p>,</span> <span class=no>R4</span>
</span></span><span class=line><span class=cl>			<span class=nf>BHI</span> <span class=no>LOOP1</span>
</span></span><span class=line><span class=cl>			<span class=nf>MOV</span> <span class=no>R2</span><span class=p>,</span> <span class=no>R4</span>
</span></span><span class=line><span class=cl><span class=nf>LOOP1</span> <span class=no>SUBS</span> <span class=no>R5</span><span class=p>,</span> <span class=c1>#1
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>BNE</span> <span class=no>LOOP</span>
</span></span><span class=line><span class=cl>		<span class=nf>LDR</span> <span class=no>R6</span><span class=p>,</span> <span class=err>=</span><span class=no>RESULT</span>
</span></span><span class=line><span class=cl>		<span class=nf>STR</span> <span class=no>R2</span><span class=p>,</span> <span class=p>[</span><span class=no>R6</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nf>L</span>		<span class=no>B</span> <span class=no>L</span>
</span></span><span class=line><span class=cl><span class=nf>VALUE1</span> <span class=no>DCD</span> <span class=mi>0X44444444</span><span class=p>,</span> <span class=mi>0X22222222</span><span class=p>,</span> <span class=mi>0X11111111</span><span class=p>,</span> <span class=mi>0X22222222</span><span class=p>,</span> <span class=mi>0XAAAAAAAA</span><span class=p>,</span> <span class=mi>0X88888888</span><span class=p>,</span> <span class=mi>0X99999999</span>
</span></span><span class=line><span class=cl>	<span class=nf>AREA</span> <span class=no>DATA2</span><span class=p>,</span> <span class=no>DATA</span><span class=p>,</span> <span class=no>READWRITE</span>
</span></span><span class=line><span class=cl><span class=nf>RESULT</span> <span class=no>DCD</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=nf>END</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>Sample input/output with calculations if necessary</p></li><li><p>Course Learning Outcome</p><ul><li>Understand the basic concepts of ARM assembly language</li><li>Understand the basic concepts of ARM assembly language programming</li><li>Understand the basic concepts of ARM assembly language programming for data processing</li><li>Understand the basic concepts of ARM assembly language programming for data processing using arrays</li></ul></li><li><p>Conclusion<br>In conclusion, the ARM assembly program efficiently finds the maximum value in an array using a loop-based approach. The code demonstrates key concepts such as register manipulation, memory access, and conditional branching.</p></li><li><p>References</p></li></ul><ol><li>Andrew N Sloss, Dominic Symes and Chris Wright, ARM system developers guide, Elsevier,
Morgan Kaufman publishers, 2008.</li><li>Shibu K V, “Introduction to Embedded Systems”, Tata McGraw Hill Education, Private Limited, 2nd Edition.</li></ol></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://aumpauskar.github.io/blog/posts/web/react/><span class=title>Next »</span><br><span>Building websites with React</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Lab expriments and termworks on x" href="https://x.com/intent/tweet/?text=Lab%20expriments%20and%20termworks&amp;url=https%3a%2f%2faumpauskar.github.io%2fblog%2fposts%2fmisc%2flab_expts%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Lab expriments and termworks on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2faumpauskar.github.io%2fblog%2fposts%2fmisc%2flab_expts%2f&amp;title=Lab%20expriments%20and%20termworks&amp;summary=Lab%20expriments%20and%20termworks&amp;source=https%3a%2f%2faumpauskar.github.io%2fblog%2fposts%2fmisc%2flab_expts%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Lab expriments and termworks on reddit" href="https://reddit.com/submit?url=https%3a%2f%2faumpauskar.github.io%2fblog%2fposts%2fmisc%2flab_expts%2f&title=Lab%20expriments%20and%20termworks"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Lab expriments and termworks on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2faumpauskar.github.io%2fblog%2fposts%2fmisc%2flab_expts%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Lab expriments and termworks on whatsapp" href="https://api.whatsapp.com/send?text=Lab%20expriments%20and%20termworks%20-%20https%3a%2f%2faumpauskar.github.io%2fblog%2fposts%2fmisc%2flab_expts%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Lab expriments and termworks on telegram" href="https://telegram.me/share/url?text=Lab%20expriments%20and%20termworks&amp;url=https%3a%2f%2faumpauskar.github.io%2fblog%2fposts%2fmisc%2flab_expts%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Lab expriments and termworks on ycombinator" href="https://news.ycombinator.com/submitlink?t=Lab%20expriments%20and%20termworks&u=https%3a%2f%2faumpauskar.github.io%2fblog%2fposts%2fmisc%2flab_expts%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://aumpauskar.github.io/blog/>Aum's blogging site</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>