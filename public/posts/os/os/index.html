<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Operating systems | Aum's blogging site</title>
<meta name=keywords content="operating systems,os,linux,unix"><meta name=description content="Operating systems Bases of an operating system Execute user programs and make solving user problems easier Make the computer system convenient to use Use the computer hardware in an efficient manner A computer system can be divided roughly into four components: the hardware, the operating system, the application programs, and the users.
Use of an operating system The operating system is responsible for the following activities in connection with process management Process creation and deletion Process suspension and resumption Provision of mechanisms for process synchronization Provision of mechanisms for process communication Provision of mechanisms for deadlock handling Operating systems is a resource allocator and it is a control program."><meta name=author content="Aum Pauskar"><link rel=canonical href=https://aumpauskar.github.io/blog/posts/os/os/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/blog/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://aumpauskar.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://aumpauskar.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://aumpauskar.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://aumpauskar.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://aumpauskar.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://aumpauskar.github.io/blog/posts/os/os/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-EV8NVH4QG5"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EV8NVH4QG5",{anonymize_ip:!1})}</script><meta property="og:title" content="Operating systems"><meta property="og:description" content="Operating systems Bases of an operating system Execute user programs and make solving user problems easier Make the computer system convenient to use Use the computer hardware in an efficient manner A computer system can be divided roughly into four components: the hardware, the operating system, the application programs, and the users.
Use of an operating system The operating system is responsible for the following activities in connection with process management Process creation and deletion Process suspension and resumption Provision of mechanisms for process synchronization Provision of mechanisms for process communication Provision of mechanisms for deadlock handling Operating systems is a resource allocator and it is a control program."><meta property="og:type" content="article"><meta property="og:url" content="https://aumpauskar.github.io/blog/posts/os/os/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-30T17:09:25+05:30"><meta property="article:modified_time" content="2023-12-30T17:09:25+05:30"><meta property="og:site_name" content="Aum's blogging site"><meta name=twitter:card content="summary"><meta name=twitter:title content="Operating systems"><meta name=twitter:description content="Operating systems Bases of an operating system Execute user programs and make solving user problems easier Make the computer system convenient to use Use the computer hardware in an efficient manner A computer system can be divided roughly into four components: the hardware, the operating system, the application programs, and the users.
Use of an operating system The operating system is responsible for the following activities in connection with process management Process creation and deletion Process suspension and resumption Provision of mechanisms for process synchronization Provision of mechanisms for process communication Provision of mechanisms for deadlock handling Operating systems is a resource allocator and it is a control program."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://aumpauskar.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"Operating systems","item":"https://aumpauskar.github.io/blog/posts/os/os/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Operating systems","name":"Operating systems","description":"Operating systems Bases of an operating system Execute user programs and make solving user problems easier Make the computer system convenient to use Use the computer hardware in an efficient manner A computer system can be divided roughly into four components: the hardware, the operating system, the application programs, and the users.\nUse of an operating system The operating system is responsible for the following activities in connection with process management Process creation and deletion Process suspension and resumption Provision of mechanisms for process synchronization Provision of mechanisms for process communication Provision of mechanisms for deadlock handling Operating systems is a resource allocator and it is a control program.","keywords":["operating systems","os","linux","unix"],"articleBody":"Operating systems Bases of an operating system Execute user programs and make solving user problems easier Make the computer system convenient to use Use the computer hardware in an efficient manner A computer system can be divided roughly into four components: the hardware, the operating system, the application programs, and the users.\nUse of an operating system The operating system is responsible for the following activities in connection with process management Process creation and deletion Process suspension and resumption Provision of mechanisms for process synchronization Provision of mechanisms for process communication Provision of mechanisms for deadlock handling Operating systems is a resource allocator and it is a control program.\nKernel The kernel is the one program running at all times on the computer. It is the core of the operating system. It performs the following functions:\nIt is a program that remains in the memory at all times and is responsible for all the major activities of the operating system It is the first program to be loaded into the memory after the booting process is completed It is the last program to be removed from the memory when the computer is shut down Other programs are classified into two categories: system programs and application programs Dual mode operation of the operating system In layman terms, the modern operating systems have two modes to run on, user mode and kernel mode. In general there are certain privalages being placed on certain programs that may only run in the kernel mode. Some computers even come with a VMM (virtual machine manager) for running guest opearting systems.\nProcess management Process creation and deletion Process suspension and resumption Provision of mechanisms for process synchronization Provision of mechanisms for process communication Provision of mechanisms for deadlock handling Memory management The job of a memory management software is to manage all process within a certain limitations of the memmory allowed by the computer’s hardware specifications. The memory management software is responsible for the following:\nKeeping track of which parts of memory are currently being used and by whom Deciding which processes (or parts thereof) and data to move into and out of memory Allocating and deallocating memory space as needed (Optional) Swapping between the main memory and the secondary memory CPU scheduling The job of a CPU scheduling software is to manage all process within a certain limitations of the CPU allowed by the computer’s hardware specifications. The CPU scheduling software is responsible for the following:\nDeciding which process to run next Deciding when to allocate and deallocate CPU to a process Deciding when to suspend and resume a process Deciding which process to move into and out of memory Deciding which process to move into and out of the secondary memory Storage management The job of a storage management software is to manage all process within a certain limitations of the storage allowed by the computer’s hardware specifications. The storage management software is responsible for the following:\nA storage management system is responsible to keep track of the status of each storage unit, whether it is allocated or free Memory management is a part of storage management Modern operating systems use a file system to manage the secondary storage The file system might be FAT, NTFS, ext4, etc. In case of a file system, the computer has a table contatining the location of all the memory blocks that are free and the ones that are occupied The storage management system is also reponsible for running data across various data blocks in SSDs to increase hardware lifespan. Various storage devices Ragisters Cache (DDR) RAM SSD / HDD Protection The operating system must ensure that the access to the resources is controlled and to ensure the isolation of the various processes The operating system must also ensure that the computer is safe from any external attacks and viruses In operating systems like Linux, the user is given a unique user ID and a group ID to ensure the users are isolated. Some operations require special privileges and are only allowed to be executed by the root user this is called superuser mode and can be accessed by the sudo command. Distributed systems Distributed systems refer to a group of computers working together as a unified computing resource. These systems often run on separate machines that are physically located in different locations, but they work together to perform tasks. They are designed to handle high levels of redundancy and replication to ensure data is always available, even in the event of a failure in part of the system. Distributed systems can be complex to manage due to issues like network latency, fault tolerance, and security concerns. However, they offer benefits in terms of scalability, performance, and reliability.\nFunctions / interfaces of an operating system GUI CLI API Batch files System calls System calls are the interface between the user-level applications and the kernel. They provide a way for programs to request services from the operating system such as file operations, process control, networking, device manipulation, and more. System calls allow user-level software to interact with hardware and system resources in a secure and controlled manner. They are crucial for the functioning of an operating system as they form the bridge between software and hardware.\nHow are system calls used System calls are used in a program when a process in user space requires resources or services from the kernel. This could be for operations such as creating processes, reading from or writing to files, communicating over network, accessing system clocks, etc.\nThe first input that the program will need is the names of the two files: the input file and the output file. These names can be specified in many ways, depending on the operating-system design. One approach is for the program to ask the user for the names of the two files. In an interactive system, this approach will require a sequence of system calls, first to write a prompting message on the screen and then to read from the keyboard the characters that define the two files. On mouse-based and icon-based systems, a menu of file names is usually displayed in a window. The user can then use the mouse to select the source name, and a window can be opened for the destination name to be specified. Processes When a linux operating system is run then many processes are created, these usually run at the user level rather running at the kernal level. Processes can be run via the ps\n1 ps Output\n1 2 3 PID TTY TIME CMD 372 pts/0 00:00:00 zsh 470 pts/0 00:00:00 ps An alternative to running the ps command is running the top or htop command. Htop is not natively installed in many systems and can be installed via sudo apt install htop in debian based systems.\nTo see every process on the system\n1 ps -e Deadlocks A deadlock is a situation in which two computer programs sharing the same resource are effectively preventing each other from accessing the resource, resulting in both programs ceasing to function. The earliest computer operating systems ran only one program at a time. All of the resources of the system were available to this one program. Later, operating systems ran multiple programs at once, interleaving them. Programs would often request resources in a specific order. If a program requested resource A and later requested resource B, another program would be able to run in between and use resource B, but not A, since it had not yet been released. If the first program then requested resource B, it would be locked out forever, since the other program had locked B and was waiting for A. This was the first and simplest sort of deadlock. Deadlocks can occur in operating systems, parallel computing, and distributed systems, as well as in everyday life.\nSafe state In the context of operating systems, a safe state is a state where the system can allocate resources to each process in some order and avoid a deadlock. In other words, a system is in a safe state if there exists a sequence (called a safe sequence) in which each process can request and be allocated all its remaining required resources, execute to completion, release all its allocated resources, and still ensure that every other process can similarly complete. If no such sequence exists, the system is said to be in an unsafe state. It’s important to note that being in an unsafe state does not imply that deadlock is inevitable, but it does mean that the risk of deadlock is present.\nSafe, unsafe, deadlock state resource allocation graph scheme Algorithms Banker’s algorithm Let n = number of processes, and m = number of resources types\nAvailable: Vecotor of length m. If available [j] = k, there are k instances of resource type Rj available. Max: n x m matrix. If Max [i,j] = k, then process Pi may request at most k instances of resource type Rj. Allocation: n x m matrix. If Allocation [i,j] = k then Pi is currently allocated k instances of Rj. Need: n x m matrix. If Need [i,j] = k, then Pi may need k more instances of Rj to complete its task. Need [i,j] = Max [i,j] - Allocation [i,j] Safety algorithm (banker’s algorithm) Let work and finish be vectors of length m and n, respectively Initialize: Work = Available Finish [i] = false for i = 0, 1, …, n-1 Find an i such that both Finish [i] = false Need \u003c Work If no such i exists, go to step 4 Work = Wirj + Allocation Finish [i] = true go to step 2 If finish [i] == true for all i, then the system is in a safe state Example Work = Available Work = 3 3 2 Finish [i] = false for i = 0, 1, 2, 3, 4\nFinish [p0] = false Need [p0] \u003c= Work 7 4 3 \u003c= 3 3 2 (false) Finish [p1] = false Need [p1] \u003c= Work 1 2 2 \u003c= 3 3 2 (true) Work = Work + Allocation [p1] 3 3 2 + 2 0 0 = 5 3 2 Work = 5 3 2\t5 5 Finish [p1] = true - 1\tFinish [p2] = false\tNeed [p2] \u003c= Work\t6 0 0 \u003c= 5 3 2 (true)\tFinish [p3] = false\tNeed [p3] \u003c= Work\t0 1 1 \u003c= 5 3 2 (true)\tWork = Work + Allocation [p3] 5 3 2 + 2 1 1 = 7 4 3 Finish [p3] = true - 2 5 5 Finish [p0] = false\tneed [p0] \u003c= Work\t4 3 1 \u003c= 7 4 3 (true)\tWork = Work + Allocation [p0]\t7 4 3 + 0 0 2 = 7 4 5\tFinish [p0] = true - 3\t5 5 Finish [p2] = false\tNeed [p2] \u003c= Work\t7 4 3 \u003c 7 4 5 (true)\tWork = Work + Allocation [p2]\t7 4 5 + 0 1 0 = 7 5 5\tFinish [p2] = true - 4\t5 5 Finish [p4] = false\tNeed [p4] \u003c= Work\t6 0 0 \u003c= 7 5 5 (true)\tWork = Work + Allocation [p4]\t7 5 5 + 3 0 2 = 10 5 7\tFinish [p4] = true - 5\t5 5 Resource request algorithm (banker’s algorithm) Request = request vector for process Pi. If request [j] = k, then process Pi wants k instances of resource type Rj.\nIf request [i] \u003c= Need [i], go to step 2. Otherwise, raise an error condition, since the process has exceeded its maximum claim.\nIf request [i] \u003c= Available, go to step 3. Otherwise, Pi must wait, since the resources are not available.\nHave the system pretend to have allocated the requested resources to process Pi by modifying the state as follows: Available = Available - request [i] Allocation [i] = Allocation [i] + request [i] Need [i] = Need [i] - request [i]\nIf safe -\u003e the resources are allocated to Pi If unsafe -\u003e Pi must wait, and the old resource-allocation state is restored Example Consider the following snapshot of a system:\nAllocation Need Available Answer the following questions using banker’s algo\nWhat is the content of the matrix Need? Need = Max - Allocation A B C D 0 | | | | | 1 | | | | | 2 | | | | | 3 | | | | | 4 | | | | | Work = 1 5 2 0 Finish [i] = false Need [p0] \u003c= Work 0 0 0 0 \u003c= 1 5 2 0 (true) Finish [p0] = true 5 5 Finish [p1] = false Nedd [p1] \u003c= Work 0 7 5 0 \u003c= 1 5 3 2 (false) Finish [p2] = false 1 0 0 2 \u003c= 1 5 3 2 (true) Work = Work + Allocation [p2] 1 5 2 0 + 1 0 0 2 = 2 5 2 2 Finish [p2] = true 5 5 Finish [p3] = false 0 0 2 0 \u003c= 2 5 2 2 (true) Work = Work + Allocation [p3] 2 5 2 2 + 0 0 2 0 = 2 5 4 2 Finish [p3] = true 5 5 Finish [p4] = false 0 6 4 6 \u003c= 2 5 4 2 (true) Work = Work + Allocation [p4] 2 5 4 2 + 0 6 4 6 = 2 11 8 8 Finish [p4] = true 5 5 Finish [p1] = false 0 7 5 0 \u003c= 2 11 8 8 (true) Work = Work + Allocation [p1] 2 11 8 8 + 0 7 5 0 = 2 18 13 8 Finish [p1] = true \\\nIs the system in a safe state? If yes then give the safety sequence. If a request from process P1 arrives for (0, 4, 2, 0), can the request be granted immediately? Producer consumer problem Producer process\nProduces information Puts information in buffer Consumer process\nConsumes information Takes information out of buffer Buffer\nShared data structure Size of buffer is fixed Producer must wait if buffer is full Consumer must wait if buffer is empty Code for producer process\n1 2 3 4 5 6 7 while (true) { /* produce an item in next_produced */ while (((in + 1) % BUFFER_SIZE) == out) /* do nothing */ buffer [in] = next_produced; in = (in + 1) % BUFFER_SIZE; } Race condition: A race condition in operating systems occurs when the behavior of a system or program depends on the relative timing or interleaving of multiple concurrent operations. It can lead to unpredictable and undesired outcomes, such as incorrect results, crashes, or deadlock. Race conditions typically arise when multiple threads or processes access shared resources or variables without proper synchronization mechanisms. Critical section problem Consider a system with n processes, each of which has a segment of code called a critical section, in which the process may be changing common variables, updating a table, writing a file, and so on. The important feature of the system is that, when one process is executing in its critical section, no other process is to be allowed to execute in its critical section. The critical-section problem is to design a protocol that the processes can use to cooperate. Each process must request permission to enter its critical section. The section of code implementing this request is the entry section. The critical section may be followed by an exit section. The remaining code is the remainder section. General structure of process P1 1 2 3 4 5 6 do { /* entry section */ /* critical section */ /* exit section */ /* remainder section */ } while (true); Solution to critical-section-problem Mutual exclusion If process Pi is executing in its critical section, then no other processes can be executing in their critical sections Progress If no process is executing in its critical section and there exist some processes that wish to enter their critical section, then the selection of the processes that will enter the critical section next cannot be postponed indefinitely Bounded waiting A bound must exist on the number of times that other processes are allowed to enter their critical sections after a process has made a request to enter its critical section and before that request is granted Memory Virual memory Copy on write Copy-on-write (COW) is a resource-management technique used in computer programming to efficiently duplicate or copy modifiable resources, such as memory pages, storage sectors, files, and data structures. The main idea is to delay the actual copying of the data until it is actually needed, which can save time and memory.\nHere’s how it works:\nSharing: Multiple users or processes can initially share a single copy of the resource. This means they all have the same pointer to the same data in memory or storage. Copy on write: If one user or process wants to modify the data, a copy is made only for that user or process. The original data is left unchanged for anyone else who is still sharing it. Private modifications: The user or process with the copy can then modify the data in their private copy without affecting the original data or anyone else who is still using the shared copy. There are several benefits to using copy-on-write:\nReduced memory usage: By sharing a single copy of the data until it needs to be modified, COW can significantly reduce memory usage. This is especially beneficial for large data sets or when there are many users or processes sharing the same data. Improved performance: Copying data can be time-consuming. By delaying the copy until it is actually needed, COW can improve the performance of applications. Simplified resource management: COW can simplify the management of resources such as memory and storage. Instead of explicitly copying data when it is needed, COW allows the system to automatically handle the copying when a modification occurs. Here are some real-world examples of how copy-on-write is used:\nOperating systems: Many operating systems use COW to implement the fork system call, which creates a new process that is a copy of an existing process. Instead of copying all of the memory used by the existing process, the new process initially shares the same memory pages. Only when the new process modifies a page is a copy made for that process. File systems: Some file systems use COW to create snapshots of files or directories. This allows users to see what the file system looked like at a previous point in time without actually copying any data. Virtualization: Virtualization software often uses COW to manage the memory used by virtual machines. This allows multiple virtual machines to share the same physical memory until they need to modify it. Page replacement Memory Pages and Page Replacement in Operating Systems Imagine your computer’s memory like a large desk, and the programs you run are like open textbooks and documents spread across it. Each textbook or document takes up a certain amount of space, just like programs use up memory. But the desk, like your computer’s memory, is limited in size.\nThis is where memory pages come in. They act like dividers on your desk, splitting the available space into smaller, manageable chunks. Each program is then divided into its own pages, which can be loaded onto the desk (memory) as needed. This allows multiple programs to share the memory space efficiently, without everything having to be loaded at once.\nHowever, there’s a catch: the desk (memory) is often much smaller than all the textbooks and documents (programs) you might want to use at once. This is where page replacement comes into play. It’s like reorganizing your desk – when you need a new document, you might put away an old one to make space.\nHere’s how page replacement works within an operating system:\nPrograms are divided into pages: Each program is broken down into fixed-size blocks called pages. These pages are like individual chapters in a book. Only some pages are loaded in memory: Not all the pages of a program need to be in memory at the same time. The operating system keeps track of which pages are currently being used and loads them into available memory frames (think of these as sections of the desk). Page fault: If a program tries to access a page that’s not in memory, a page fault occurs. This is like realizing you need a specific chapter of a book that’s not on your desk. Page replacement algorithm: The operating system then uses a page replacement algorithm to decide which page in memory to evict (put away) to make room for the needed page. This is like choosing which document to temporarily remove from your desk. Swapping pages: The evicted page is written to disk (like putting a document in a drawer) and the needed page is loaded into memory from disk (like taking a new document from your bag). There are different page replacement algorithms, each with its own advantages and disadvantages. Some common ones include:\nFirst-In-First-Out (FIFO): Evicts the page that has been in memory the longest, regardless of how recently it was used. (Think of taking out the first document you put on your desk.)\nExample: 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3 ,2, 1, 2 ,0 ,1, 7, 0, 1 Consider the follwoing string and identify the page faults for three frames 7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1 7 7 0 2 What do you mean by belady’s anomaly and what does it indicate?\nA: Belady’s anomaly occurs whan more frames are added in the memory pages the page faults will increase. It is an edge case scenario.\nHere as you can see in this example of finding page faults\nLeast Recently Used (LRU): Evicts the page that has been used the least recently. (Think of taking out the document you haven’t touched in a while.) Most Recently Used (MRU)/optimal algorithm: Never evicts the page that was most recently used. (Think of always keeping the document you’re currently using on your desk.) ","wordCount":"3718","inLanguage":"en","datePublished":"2023-12-30T17:09:25+05:30","dateModified":"2023-12-30T17:09:25+05:30","author":{"@type":"Person","name":"Aum Pauskar"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://aumpauskar.github.io/blog/posts/os/os/"},"publisher":{"@type":"Organization","name":"Aum's blogging site","logo":{"@type":"ImageObject","url":"https://aumpauskar.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://aumpauskar.github.io/blog/ accesskey=h title="Aum's blogging site (Alt + H)">Aum's blogging site</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://aumpauskar.github.io/blog/>Home</a>&nbsp;»&nbsp;<a href=https://aumpauskar.github.io/blog/posts/>Posts</a></div><h1 class=post-title>Operating systems</h1><div class=post-meta><span title='2023-12-30 17:09:25 +0530 IST'>December 30, 2023</span>&nbsp;·&nbsp;18 min&nbsp;·&nbsp;3718 words&nbsp;·&nbsp;Aum Pauskar</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#bases-of-an-operating-system>Bases of an operating system</a><ul><li><a href=#use-of-an-operating-system>Use of an operating system</a></li><li><a href=#kernel>Kernel</a></li><li><a href=#dual-mode-operation-of-the-operating-system>Dual mode operation of the operating system</a></li><li><a href=#process-management>Process management</a></li><li><a href=#memory-management>Memory management</a></li><li><a href=#cpu-scheduling>CPU scheduling</a></li><li><a href=#storage-management>Storage management</a></li><li><a href=#protection>Protection</a></li><li><a href=#distributed-systems>Distributed systems</a></li><li><a href=#functions--interfaces-of-an-operating-system>Functions / interfaces of an operating system</a></li><li><a href=#system-calls>System calls</a></li></ul></li><li><a href=#processes>Processes</a></li><li><a href=#deadlocks>Deadlocks</a></li><li><a href=#safe-state>Safe state</a><ul><li><a href=#safe-unsafe-deadlock-state>Safe, unsafe, deadlock state</a></li></ul></li><li><a href=#algorithms>Algorithms</a><ul><li><a href=#bankers-algorithm>Banker&rsquo;s algorithm</a></li><li><a href=#safety-algorithm-bankers-algorithm>Safety algorithm (banker&rsquo;s algorithm)</a></li><li><a href=#resource-request-algorithm-bankers-algorithm>Resource request algorithm (banker&rsquo;s algorithm)</a></li><li><a href=#example-1>Example</a></li><li><a href=#producer-consumer-problem>Producer consumer problem</a></li><li><a href=#critical-section-problem>Critical section problem</a></li></ul></li><li><a href=#memory>Memory</a></li><li><a href=#virual-memory>Virual memory</a><ul><li><a href=#copy-on-write>Copy on write</a></li><li><a href=#page-replacement>Page replacement</a></li></ul></li><li><a href=#memory-pages-and-page-replacement-in-operating-systems>Memory Pages and Page Replacement in Operating Systems</a></li></ul></nav></div></details></div><div class=post-content><h1 id=operating-systems>Operating systems<a hidden class=anchor aria-hidden=true href=#operating-systems>#</a></h1><h2 id=bases-of-an-operating-system>Bases of an operating system<a hidden class=anchor aria-hidden=true href=#bases-of-an-operating-system>#</a></h2><ul><li>Execute user programs and make solving user problems easier</li><li>Make the computer system convenient to use</li><li>Use the computer hardware in an efficient manner</li></ul><p>A computer system can be divided roughly into four components: the <strong>hardware</strong>, the <strong>operating system</strong>, the <strong>application programs</strong>, and the <strong>users</strong>.</p><h3 id=use-of-an-operating-system>Use of an operating system<a hidden class=anchor aria-hidden=true href=#use-of-an-operating-system>#</a></h3><ul><li>The operating system is responsible for the following activities in connection with process management<ul><li>Process creation and deletion</li><li>Process suspension and resumption</li><li>Provision of mechanisms for process synchronization</li><li>Provision of mechanisms for process communication</li><li>Provision of mechanisms for deadlock handling</li></ul></li></ul><p>Operating systems is a <strong>resource allocator</strong> and it is a <strong>control program</strong>.</p><h3 id=kernel>Kernel<a hidden class=anchor aria-hidden=true href=#kernel>#</a></h3><p>The kernel is the one program running at all times on the computer. It is the core of the operating system. It performs the following functions:</p><ul><li>It is a program that remains in the memory at all times and is responsible for all the major activities of the operating system</li><li>It is the first program to be loaded into the memory after the booting process is completed</li><li>It is the last program to be removed from the memory when the computer is shut down</li><li>Other programs are classified into two categories: <strong>system programs</strong> and <strong>application programs</strong></li></ul><h3 id=dual-mode-operation-of-the-operating-system>Dual mode operation of the operating system<a hidden class=anchor aria-hidden=true href=#dual-mode-operation-of-the-operating-system>#</a></h3><p>In layman terms, the modern operating systems have two modes to run on, user mode and kernel mode. In general there are certain privalages being placed on certain programs that may only run in the kernel mode. Some computers even come with a VMM (virtual machine manager) for running guest opearting systems.</p><h3 id=process-management>Process management<a hidden class=anchor aria-hidden=true href=#process-management>#</a></h3><ul><li>Process creation and deletion</li><li>Process suspension and resumption</li><li>Provision of mechanisms for process synchronization</li><li>Provision of mechanisms for process communication</li><li>Provision of mechanisms for deadlock handling</li></ul><h3 id=memory-management>Memory management<a hidden class=anchor aria-hidden=true href=#memory-management>#</a></h3><p>The job of a memory management software is to manage all process within a certain limitations of the memmory allowed by the computer&rsquo;s hardware specifications. The memory management software is responsible for the following:</p><ul><li>Keeping track of which parts of memory are currently being used and by whom</li><li>Deciding which processes (or parts thereof) and data to move into and out of memory</li><li>Allocating and deallocating memory space as needed</li><li>(Optional) Swapping between the main memory and the secondary memory</li></ul><h3 id=cpu-scheduling>CPU scheduling<a hidden class=anchor aria-hidden=true href=#cpu-scheduling>#</a></h3><p>The job of a CPU scheduling software is to manage all process within a certain limitations of the CPU allowed by the computer&rsquo;s hardware specifications. The CPU scheduling software is responsible for the following:</p><ul><li>Deciding which process to run next</li><li>Deciding when to allocate and deallocate CPU to a process</li><li>Deciding when to suspend and resume a process</li><li>Deciding which process to move into and out of memory</li><li>Deciding which process to move into and out of the secondary memory</li></ul><h3 id=storage-management>Storage management<a hidden class=anchor aria-hidden=true href=#storage-management>#</a></h3><p>The job of a storage management software is to manage all process within a certain limitations of the storage allowed by the computer&rsquo;s hardware specifications. The storage management software is responsible for the following:</p><ul><li>A storage management system is responsible to keep track of the status of each storage unit, whether it is allocated or free</li><li>Memory management is a part of storage management</li><li>Modern operating systems use a file system to manage the secondary storage</li><li>The file system might be FAT, NTFS, ext4, etc.</li><li>In case of a file system, the computer has a table contatining the location of all the memory blocks that are free and the ones that are occupied</li><li>The storage management system is also reponsible for running data across various data blocks in SSDs to increase hardware lifespan.</li><li>Various storage devices<ul><li>Ragisters</li><li>Cache</li><li>(DDR) RAM</li><li>SSD / HDD</li></ul></li></ul><h3 id=protection>Protection<a hidden class=anchor aria-hidden=true href=#protection>#</a></h3><ul><li>The operating system must ensure that the access to the resources is controlled and to ensure the isolation of the various processes</li><li>The operating system must also ensure that the computer is safe from any external attacks and viruses</li><li>In operating systems like Linux, the user is given a unique user ID and a group ID to ensure the users are isolated.</li><li>Some operations require special privileges and are only allowed to be executed by the root user this is called superuser mode and can be accessed by the <code>sudo</code> command.</li></ul><h3 id=distributed-systems>Distributed systems<a hidden class=anchor aria-hidden=true href=#distributed-systems>#</a></h3><p>Distributed systems refer to a group of computers working together as a unified computing resource. These systems often run on separate machines that are physically located in different locations, but they work together to perform tasks. They are designed to handle high levels of redundancy and replication to ensure data is always available, even in the event of a failure in part of the system. Distributed systems can be complex to manage due to issues like network latency, fault tolerance, and security concerns. However, they offer benefits in terms of scalability, performance, and reliability.</p><h3 id=functions--interfaces-of-an-operating-system>Functions / interfaces of an operating system<a hidden class=anchor aria-hidden=true href=#functions--interfaces-of-an-operating-system>#</a></h3><ul><li>GUI</li><li>CLI</li><li>API</li><li>Batch files</li></ul><h3 id=system-calls>System calls<a hidden class=anchor aria-hidden=true href=#system-calls>#</a></h3><p>System calls are the interface between the user-level applications and the kernel. They provide a way for programs to request services from the operating system such as file operations, process control, networking, device manipulation, and more. System calls allow user-level software to interact with hardware and system resources in a secure and controlled manner. They are crucial for the functioning of an operating system as they form the bridge between software and hardware.</p><ul><li><p>How are system calls used<br>System calls are used in a program when a process in user space requires resources or services from the kernel. This could be for operations such as creating processes, reading from or writing to files, communicating over network, accessing system clocks, etc.</p><ul><li>The first input that the program will need is the names of the two files: the input file and the output file. These names can be specified in many ways, depending on the operating-system design.</li><li>One approach is for the program to ask the user for the names of the two files.</li><li>In an interactive system, this approach will require a sequence of system calls, first to write a prompting message on the screen and then to read from the keyboard the characters that define the two files.</li><li>On mouse-based and icon-based systems, a menu of file names is usually displayed in a window. The user can then use the mouse to select the source name, and a window can be opened for the destination name to be specified.</li></ul></li></ul><h2 id=processes>Processes<a hidden class=anchor aria-hidden=true href=#processes>#</a></h2><p>When a linux operating system is run then many processes are created, these usually run at the user level rather running at the kernal level.<br>Processes can be run via the <code>ps</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>ps
</span></span></code></pre></td></tr></table></div></div><p>Output</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>    PID TTY          TIME CMD
</span></span><span class=line><span class=cl>    372 pts/0    00:00:00 zsh
</span></span><span class=line><span class=cl>    470 pts/0    00:00:00 ps
</span></span></code></pre></td></tr></table></div></div><p>An alternative to running the ps command is running the <code>top</code> or <code>htop</code> command. Htop is not natively installed in many systems and can be installed via <code>sudo apt install htop</code> in debian based systems.<br>To see every process on the system</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>ps -e
</span></span></code></pre></td></tr></table></div></div><h2 id=deadlocks>Deadlocks<a hidden class=anchor aria-hidden=true href=#deadlocks>#</a></h2><p>A deadlock is a situation in which two computer programs sharing the same resource are effectively preventing each other from accessing the resource, resulting in both programs ceasing to function. The earliest computer operating systems ran only one program at a time. All of the resources of the system were available to this one program. Later, operating systems ran multiple programs at once, interleaving them. Programs would often request resources in a specific order. If a program requested resource A and later requested resource B, another program would be able to run in between and use resource B, but not A, since it had not yet been released. If the first program then requested resource B, it would be locked out forever, since the other program had locked B and was waiting for A. This was the first and simplest sort of deadlock. Deadlocks can occur in operating systems, parallel computing, and distributed systems, as well as in everyday life.</p><h2 id=safe-state>Safe state<a hidden class=anchor aria-hidden=true href=#safe-state>#</a></h2><p>In the context of operating systems, a safe state is a state where the system can allocate resources to each process in some order and avoid a deadlock. In other words, a system is in a safe state if there exists a sequence (called a safe sequence) in which each process can request and be allocated all its remaining required resources, execute to completion, release all its allocated resources, and still ensure that every other process can similarly complete. If no such sequence exists, the system is said to be in an unsafe state. It&rsquo;s important to note that being in an unsafe state does not imply that deadlock is inevitable, but it does mean that the risk of deadlock is present.</p><h3 id=safe-unsafe-deadlock-state>Safe, unsafe, deadlock state<a hidden class=anchor aria-hidden=true href=#safe-unsafe-deadlock-state>#</a></h3><ul><li>resource allocation graph scheme</li></ul><h2 id=algorithms>Algorithms<a hidden class=anchor aria-hidden=true href=#algorithms>#</a></h2><h3 id=bankers-algorithm>Banker&rsquo;s algorithm<a hidden class=anchor aria-hidden=true href=#bankers-algorithm>#</a></h3><p>Let n = number of processes, and m = number of resources types</p><ul><li>Available: Vecotor of length m. If available [j] = k, there are k instances of resource type Rj available.</li><li>Max: n x m matrix. If Max [i,j] = k, then process Pi may request at most k instances of resource type Rj.</li><li>Allocation: n x m matrix. If Allocation [i,j] = k then Pi is currently allocated k instances of Rj.</li><li>Need: n x m matrix. If Need [i,j] = k, then Pi may need k more instances of Rj to complete its task.</li><li>Need [i,j] = Max [i,j] - Allocation [i,j]</li></ul><h3 id=safety-algorithm-bankers-algorithm>Safety algorithm (banker&rsquo;s algorithm)<a hidden class=anchor aria-hidden=true href=#safety-algorithm-bankers-algorithm>#</a></h3><ul><li>Let work and finish be vectors of length m and n, respectively
Initialize:
Work = Available
Finish [i] = false for i = 0, 1, &mldr;, n-1</li><li>Find an i such that both<ul><li>Finish [i] = false</li><li>Need &lt; Work
If no such i exists, go to step 4</li></ul></li><li>Work = Wirj + Allocation
Finish [i] = true
go to step 2</li><li>If finish [i] == true for all i, then the system is in a safe state</li></ul><h4 id=example>Example<a hidden class=anchor aria-hidden=true href=#example>#</a></h4><ol><li><p>Work = Available<br>Work = 3 3 2<br>Finish [i] = false for i = 0, 1, 2, 3, 4</p></li><li><p>Finish [p0] = false<br>Need [p0] &lt;= Work<br>7 4 3 &lt;= 3 3 2 (false)<br>Finish [p1] = false<br>Need [p1] &lt;= Work<br>1 2 2 &lt;= 3 3 2 (true)<br>Work = Work + Allocation [p1]<br>3 3 2 + 2 0 0 = 5 3 2<br>Work = 5 3 2<br>5 5<br><strong>Finish [p1] = true</strong> - 1<br><strong>Finish [p2] = false</strong><br>Need [p2] &lt;= Work<br>6 0 0 &lt;= 5 3 2 (true)<br>Finish [p3] = false<br>Need [p3] &lt;= Work<br>0 1 1 &lt;= 5 3 2 (true)<br>Work = Work + Allocation [p3]<br>5 3 2 + 2 1 1 = 7 4 3<br><strong>Finish [p3] = true</strong> - 2<br>5 5<br>Finish [p0] = false<br>need [p0] &lt;= Work<br>4 3 1 &lt;= 7 4 3 (true)<br>Work = Work + Allocation [p0]<br>7 4 3 + 0 0 2 = 7 4 5<br><strong>Finish [p0] = true</strong> - 3<br>5 5<br>Finish [p2] = false<br>Need [p2] &lt;= Work<br>7 4 3 &lt; 7 4 5 (true)<br>Work = Work + Allocation [p2]<br>7 4 5 + 0 1 0 = 7 5 5<br><strong>Finish [p2] = true</strong> - 4<br>5 5<br>Finish [p4] = false<br>Need [p4] &lt;= Work<br>6 0 0 &lt;= 7 5 5 (true)<br>Work = Work + Allocation [p4]<br>7 5 5 + 3 0 2 = 10 5 7<br><strong>Finish [p4] = true</strong> - 5<br>5 5</p></li></ol><h3 id=resource-request-algorithm-bankers-algorithm>Resource request algorithm (banker&rsquo;s algorithm)<a hidden class=anchor aria-hidden=true href=#resource-request-algorithm-bankers-algorithm>#</a></h3><p>Request = request vector for process Pi. If request [j] = k, then process Pi wants k instances of resource type Rj.</p><ol><li><p>If request [i] &lt;= Need [i], go to step 2. Otherwise, raise an error condition, since the process has exceeded its maximum claim.</p></li><li><p>If request [i] &lt;= Available, go to step 3. Otherwise, Pi must wait, since the resources are not available.</p></li><li><p>Have the system pretend to have allocated the requested resources to process Pi by modifying the state as follows:
Available = Available - request [i]
Allocation [i] = Allocation [i] + request [i]
Need [i] = Need [i] - request [i]</p><ul><li>If safe -> the resources are allocated to Pi</li><li>If unsafe -> Pi must wait, and the old resource-allocation state is restored</li></ul></li></ol><h3 id=example-1>Example<a hidden class=anchor aria-hidden=true href=#example-1>#</a></h3><p>Consider the following snapshot of a system:</p><table><thead><tr><th></th><th>Allocation</th><th>Need</th><th>Available</th></tr></thead></table><ul><li><p>Answer the following questions using banker&rsquo;s algo</p><ul><li>What is the content of the matrix Need?<br>Need = Max - Allocation</li></ul><table><thead><tr><th></th><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>0 |</td><td>|</td><td>|</td><td>|</td><td>|</td></tr><tr><td>1 |</td><td>|</td><td>|</td><td>|</td><td>|</td></tr><tr><td>2 |</td><td>|</td><td>|</td><td>|</td><td>|</td></tr><tr><td>3 |</td><td>|</td><td>|</td><td>|</td><td>|</td></tr><tr><td>4 |</td><td>|</td><td>|</td><td>|</td><td>|</td></tr></tbody></table><p>Work = 1 5 2 0<br>Finish [i] = false
Need [p0] &lt;= Work<br>0 0 0 0 &lt;= 1 5 2 0 (true)<br>Finish [p0] = true<br>5 5 Finish [p1] = false<br>Nedd [p1] &lt;= Work<br>0 7 5 0 &lt;= 1 5 3 2 (false)<br>Finish [p2] = false<br>1 0 0 2 &lt;= 1 5 3 2 (true)<br>Work = Work + Allocation [p2]<br>1 5 2 0 + 1 0 0 2 = 2 5 2 2<br>Finish [p2] = true<br>5 5<br>Finish [p3] = false<br>0 0 2 0 &lt;= 2 5 2 2 (true)<br>Work = Work + Allocation [p3]<br>2 5 2 2 + 0 0 2 0 = 2 5 4 2<br>Finish [p3] = true<br>5 5<br>Finish [p4] = false<br>0 6 4 6 &lt;= 2 5 4 2 (true)<br>Work = Work + Allocation [p4]<br>2 5 4 2 + 0 6 4 6 = 2 11 8 8<br>Finish [p4] = true<br>5 5<br>Finish [p1] = false<br>0 7 5 0 &lt;= 2 11 8 8 (true)<br>Work = Work + Allocation [p1]<br>2 11 8 8 + 0 7 5 0 = 2 18 13 8<br>Finish [p1] = true \</p><ul><li>Is the system in a safe state? If yes then give the safety sequence.</li><li>If a request from process P1 arrives for (0, 4, 2, 0), can the request be granted immediately?</li></ul></li></ul><h3 id=producer-consumer-problem>Producer consumer problem<a hidden class=anchor aria-hidden=true href=#producer-consumer-problem>#</a></h3><ul><li><p>Producer process</p><ul><li>Produces information</li><li>Puts information in buffer</li></ul></li><li><p>Consumer process</p><ul><li>Consumes information</li><li>Takes information out of buffer</li></ul></li><li><p>Buffer</p><ul><li>Shared data structure</li><li>Size of buffer is fixed</li><li>Producer must wait if buffer is full</li><li>Consumer must wait if buffer is empty</li></ul></li><li><p>Code for producer process</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4>4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5>5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6>6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* produce an item in next_produced */</span>
</span></span><span class=line><span class=cl>	<span class=k>while</span> <span class=p>(((</span><span class=n>in</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=n>BUFFER_SIZE</span><span class=p>)</span> <span class=o>==</span> <span class=n>out</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=cm>/* do nothing */</span>
</span></span><span class=line><span class=cl>	<span class=n>buffer</span> <span class=p>[</span><span class=n>in</span><span class=p>]</span> <span class=o>=</span> <span class=n>next_produced</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>in</span> <span class=o>=</span> <span class=p>(</span><span class=n>in</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=n>BUFFER_SIZE</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>Race condition: A race condition in operating systems occurs when the behavior of a system or program depends on the relative timing or interleaving of multiple concurrent operations. It can lead to unpredictable and undesired outcomes, such as incorrect results, crashes, or deadlock. Race conditions typically arise when multiple threads or processes access shared resources or variables without proper synchronization mechanisms.</li></ul><h3 id=critical-section-problem>Critical section problem<a hidden class=anchor aria-hidden=true href=#critical-section-problem>#</a></h3><ul><li>Consider a system with n processes, each of which has a segment of code called a critical section, in which the process may be changing common variables, updating a table, writing a file, and so on.</li><li>The important feature of the system is that, when one process is executing in its critical section, no other process is to be allowed to execute in its critical section.</li><li>The critical-section problem is to design a protocol that the processes can use to cooperate. Each process must request permission to enter its critical section. The section of code implementing this request is the entry section. The critical section may be followed by an exit section. The remaining code is the remainder section.</li><li>General structure of process P1</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3>3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4>4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5>5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* entry section */</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* critical section */</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* exit section */</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* remainder section */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>Solution to critical-section-problem<ul><li>Mutual exclusion<ul><li>If process Pi is executing in its critical section, then no other processes can be executing in their critical sections</li></ul></li><li>Progress<ul><li>If no process is executing in its critical section and there exist some processes that wish to enter their critical section, then the selection of the processes that will enter the critical section next cannot be postponed indefinitely</li></ul></li><li>Bounded waiting<ul><li>A bound must exist on the number of times that other processes are allowed to enter their critical sections after a process has made a request to enter its critical section and before that request is granted</li></ul></li></ul></li></ul><h2 id=memory>Memory<a hidden class=anchor aria-hidden=true href=#memory>#</a></h2><h2 id=virual-memory>Virual memory<a hidden class=anchor aria-hidden=true href=#virual-memory>#</a></h2><h3 id=copy-on-write>Copy on write<a hidden class=anchor aria-hidden=true href=#copy-on-write>#</a></h3><p>Copy-on-write (COW) is a resource-management technique used in computer programming to efficiently duplicate or copy modifiable resources, such as memory pages, storage sectors, files, and data structures. The main idea is to delay the actual copying of the data until it is actually needed, which can save time and memory.</p><p>Here&rsquo;s how it works:</p><ol><li><strong>Sharing</strong>: Multiple users or processes can initially share a single copy of the resource. This means they all have the same pointer to the same data in memory or storage.</li><li><strong>Copy on write</strong>: If one user or process wants to modify the data, a copy is made <strong>only for that user or process</strong>. The original data is left unchanged for anyone else who is still sharing it.</li><li><strong>Private modifications</strong>: The user or process with the copy can then modify the data in their private copy without affecting the original data or anyone else who is still using the shared copy.</li></ol><p>There are several benefits to using copy-on-write:</p><ul><li><strong>Reduced memory usage</strong>: By sharing a single copy of the data until it needs to be modified, COW can significantly reduce memory usage. This is especially beneficial for large data sets or when there are many users or processes sharing the same data.</li><li><strong>Improved performance</strong>: Copying data can be time-consuming. By delaying the copy until it is actually needed, COW can improve the performance of applications.</li><li><strong>Simplified resource management</strong>: COW can simplify the management of resources such as memory and storage. Instead of explicitly copying data when it is needed, COW allows the system to automatically handle the copying when a modification occurs.</li></ul><p>Here are some real-world examples of how copy-on-write is used:</p><ul><li><strong>Operating systems</strong>: Many operating systems use COW to implement the <code>fork</code> system call, which creates a new process that is a copy of an existing process. Instead of copying all of the memory used by the existing process, the new process initially shares the same memory pages. Only when the new process modifies a page is a copy made for that process.</li><li><strong>File systems</strong>: Some file systems use COW to create snapshots of files or directories. This allows users to see what the file system looked like at a previous point in time without actually copying any data.</li><li><strong>Virtualization</strong>: Virtualization software often uses COW to manage the memory used by virtual machines. This allows multiple virtual machines to share the same physical memory until they need to modify it.</li></ul><h3 id=page-replacement>Page replacement<a hidden class=anchor aria-hidden=true href=#page-replacement>#</a></h3><h2 id=memory-pages-and-page-replacement-in-operating-systems>Memory Pages and Page Replacement in Operating Systems<a hidden class=anchor aria-hidden=true href=#memory-pages-and-page-replacement-in-operating-systems>#</a></h2><p>Imagine your computer&rsquo;s memory like a large desk, and the programs you run are like open textbooks and documents spread across it. Each textbook or document takes up a certain amount of space, just like programs use up memory. But the desk, like your computer&rsquo;s memory, is limited in size.</p><p>This is where <strong>memory pages</strong> come in. They act like dividers on your desk, splitting the available space into smaller, manageable chunks. Each program is then divided into its own pages, which can be loaded onto the desk (memory) as needed. This allows multiple programs to share the memory space efficiently, without everything having to be loaded at once.</p><p>However, there&rsquo;s a catch: the desk (memory) is often much smaller than all the textbooks and documents (programs) you might want to use at once. This is where <strong>page replacement</strong> comes into play. It&rsquo;s like reorganizing your desk – when you need a new document, you might put away an old one to make space.</p><p>Here&rsquo;s how page replacement works within an operating system:</p><ol><li><strong>Programs are divided into pages</strong>: Each program is broken down into fixed-size blocks called pages. These pages are like individual chapters in a book.</li><li><strong>Only some pages are loaded in memory</strong>: Not all the pages of a program need to be in memory at the same time. The operating system keeps track of which pages are currently being used and loads them into available memory frames (think of these as sections of the desk).</li><li><strong>Page fault</strong>: If a program tries to access a page that&rsquo;s not in memory, a <strong>page fault</strong> occurs. This is like realizing you need a specific chapter of a book that&rsquo;s not on your desk.</li><li><strong>Page replacement algorithm</strong>: The operating system then uses a <strong>page replacement algorithm</strong> to decide which page in memory to evict (put away) to make room for the needed page. This is like choosing which document to temporarily remove from your desk.</li><li><strong>Swapping pages</strong>: The evicted page is written to disk (like putting a document in a drawer) and the needed page is loaded into memory from disk (like taking a new document from your bag).</li></ol><p>There are different page replacement algorithms, each with its own advantages and disadvantages. Some common ones include:</p><ul><li><strong>First-In-First-Out (FIFO)</strong>: Evicts the page that has been in memory the longest, regardless of how recently it was used. (Think of taking out the first document you put on your desk.)<br><strong>Example</strong>: <code>7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3 ,2, 1, 2 ,0 ,1, 7, 0, 1</code>
Consider the follwoing string and identify the page faults for three frames</li></ul><table><thead><tr><th>7</th><th>0</th><th>1</th><th>2</th><th>0</th><th>3</th><th>0</th><th>4</th><th>2</th><th>3</th><th>0</th><th>3</th><th>2</th><th>1</th><th>2</th><th>0</th><th>1</th><th>7</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>7</td><td>7</td><td>0</td><td>2</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>What do you mean by <strong>belady&rsquo;s anomaly</strong> and what does it indicate?<br>A: Belady&rsquo;s anomaly occurs whan more frames are added in the memory pages the page faults will increase. It is an edge case scenario.</p><p>Here as you can see in this example of finding page faults</p><ul><li><strong>Least Recently Used (LRU)</strong>: Evicts the page that has been used the least recently. (Think of taking out the document you haven&rsquo;t touched in a while.)</li><li><strong>Most Recently Used (MRU)/optimal algorithm</strong>: Never evicts the page that was most recently used. (Think of always keeping the document you&rsquo;re currently using on your desk.)</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://aumpauskar.github.io/blog/tags/operating-systems/>Operating Systems</a></li><li><a href=https://aumpauskar.github.io/blog/tags/os/>Os</a></li><li><a href=https://aumpauskar.github.io/blog/tags/linux/>Linux</a></li><li><a href=https://aumpauskar.github.io/blog/tags/unix/>Unix</a></li></ul><nav class=paginav><a class=prev href=https://aumpauskar.github.io/blog/posts/dsa/leetcode/><span class=title>« Prev</span><br><span>Leetcode solutions</span>
</a><a class=next href=https://aumpauskar.github.io/blog/posts/misc/zsh/><span class=title>Next »</span><br><span>ZSH configuration</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Operating systems on x" href="https://x.com/intent/tweet/?text=Operating%20systems&amp;url=https%3a%2f%2faumpauskar.github.io%2fblog%2fposts%2fos%2fos%2f&amp;hashtags=operatingsystems%2cos%2clinux%2cunix"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share Operating systems on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2faumpauskar.github.io%2fblog%2fposts%2fos%2fos%2f&amp;title=Operating%20systems&amp;summary=Operating%20systems&amp;source=https%3a%2f%2faumpauskar.github.io%2fblog%2fposts%2fos%2fos%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share Operating systems on reddit" href="https://reddit.com/submit?url=https%3a%2f%2faumpauskar.github.io%2fblog%2fposts%2fos%2fos%2f&title=Operating%20systems"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share Operating systems on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2faumpauskar.github.io%2fblog%2fposts%2fos%2fos%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share Operating systems on whatsapp" href="https://api.whatsapp.com/send?text=Operating%20systems%20-%20https%3a%2f%2faumpauskar.github.io%2fblog%2fposts%2fos%2fos%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share Operating systems on telegram" href="https://telegram.me/share/url?text=Operating%20systems&amp;url=https%3a%2f%2faumpauskar.github.io%2fblog%2fposts%2fos%2fos%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share Operating systems on ycombinator" href="https://news.ycombinator.com/submitlink?t=Operating%20systems&u=https%3a%2f%2faumpauskar.github.io%2fblog%2fposts%2fos%2fos%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://aumpauskar.github.io/blog/>Aum's blogging site</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>