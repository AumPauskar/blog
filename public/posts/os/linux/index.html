<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Linux | Aum's blogging site</title>
<meta name=keywords content><meta name=description content="Linux/UNIX shell commands The UNIX shell is a command-line interface made for interacting with the OS. There are various commands to execute this.
Note: The current documentaiton is based on Ububtu and similar debian bases operating systems.
Bases of an operating system Execute user programs and make solving user problems easier Make the computer system convenient to use Use the computer hardware in an efficient manner A computer system can be divided roughly into four components: the hardware, the operating system, the application programs, and the users."><meta name=author content="Aum Pauskar"><link rel=canonical href=https://aumpauskar.github.io/blog/posts/os/linux/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/blog/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://aumpauskar.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://aumpauskar.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://aumpauskar.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://aumpauskar.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://aumpauskar.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-EV8NVH4QG5"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EV8NVH4QG5",{anonymize_ip:!1})}</script><meta property="og:title" content="Linux"><meta property="og:description" content="Linux/UNIX shell commands The UNIX shell is a command-line interface made for interacting with the OS. There are various commands to execute this.
Note: The current documentaiton is based on Ububtu and similar debian bases operating systems.
Bases of an operating system Execute user programs and make solving user problems easier Make the computer system convenient to use Use the computer hardware in an efficient manner A computer system can be divided roughly into four components: the hardware, the operating system, the application programs, and the users."><meta property="og:type" content="article"><meta property="og:url" content="https://aumpauskar.github.io/blog/posts/os/linux/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-23T12:52:03+05:30"><meta property="article:modified_time" content="2023-11-23T12:52:03+05:30"><meta property="og:site_name" content="Aum's blogging site"><meta name=twitter:card content="summary"><meta name=twitter:title content="Linux"><meta name=twitter:description content="Linux/UNIX shell commands The UNIX shell is a command-line interface made for interacting with the OS. There are various commands to execute this.
Note: The current documentaiton is based on Ububtu and similar debian bases operating systems.
Bases of an operating system Execute user programs and make solving user problems easier Make the computer system convenient to use Use the computer hardware in an efficient manner A computer system can be divided roughly into four components: the hardware, the operating system, the application programs, and the users."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://aumpauskar.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"Linux","item":"https://aumpauskar.github.io/blog/posts/os/linux/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Linux","name":"Linux","description":"Linux/UNIX shell commands The UNIX shell is a command-line interface made for interacting with the OS. There are various commands to execute this.\nNote: The current documentaiton is based on Ububtu and similar debian bases operating systems.\nBases of an operating system Execute user programs and make solving user problems easier Make the computer system convenient to use Use the computer hardware in an efficient manner A computer system can be divided roughly into four components: the hardware, the operating system, the application programs, and the users.","keywords":[],"articleBody":"Linux/UNIX shell commands The UNIX shell is a command-line interface made for interacting with the OS. There are various commands to execute this.\nNote: The current documentaiton is based on Ububtu and similar debian bases operating systems.\nBases of an operating system Execute user programs and make solving user problems easier Make the computer system convenient to use Use the computer hardware in an efficient manner A computer system can be divided roughly into four components: the hardware, the operating system, the application programs, and the users.\nUse of an operating system The operating system is responsible for the following activities in connection with process management Process creation and deletion Process suspension and resumption Provision of mechanisms for process synchronization Provision of mechanisms for process communication Provision of mechanisms for deadlock handling Operating systems is a resource allocator and it is a control program.\nKernel The kernel is the one program running at all times on the computer. It is the core of the operating system. It performs the following functions:\nIt is a program that remains in the memory at all times and is responsible for all the major activities of the operating system It is the first program to be loaded into the memory after the booting process is completed It is the last program to be removed from the memory when the computer is shut down Other programs are classified into two categories: system programs and application programs Dual mode operation of the operating system In layman terms, the modern operating systems have two modes to run on, user mode and kernel mode. In general there are certain privalages being placed on certain programs that may only run in the kernel mode. Some computers even come with a VMM (virtual machine manager) for running guest opearting systems.\nProcess management Process creation and deletion Process suspension and resumption Provision of mechanisms for process synchronization Provision of mechanisms for process communication Provision of mechanisms for deadlock handling Memory management The job of a memory management software is to manage all process within a certain limitations of the memmory allowed by the computer’s hardware specifications. The memory management software is responsible for the following:\nKeeping track of which parts of memory are currently being used and by whom Deciding which processes (or parts thereof) and data to move into and out of memory Allocating and deallocating memory space as needed (Optional) Swapping between the main memory and the secondary memory CPU scheduling The job of a CPU scheduling software is to manage all process within a certain limitations of the CPU allowed by the computer’s hardware specifications. The CPU scheduling software is responsible for the following:\nDeciding which process to run next Deciding when to allocate and deallocate CPU to a process Deciding when to suspend and resume a process Deciding which process to move into and out of memory Deciding which process to move into and out of the secondary memory Storage management The job of a storage management software is to manage all process within a certain limitations of the storage allowed by the computer’s hardware specifications. The storage management software is responsible for the following:\nA storage management system is responsible to keep track of the status of each storage unit, whether it is allocated or free Memory management is a part of storage management Modern operating systems use a file system to manage the secondary storage The file system might be FAT, NTFS, ext4, etc. In case of a file system, the computer has a table contatining the location of all the memory blocks that are free and the ones that are occupied The storage management system is also reponsible for running data across various data blocks in SSDs to increase hardware lifespan. Various storage devices Ragisters Cache (DDR) RAM SSD / HDD Protection The operating system must ensure that the access to the resources is controlled and to ensure the isolation of the various processes The operating system must also ensure that the computer is safe from any external attacks and viruses In operating systems like Linux, the user is given a unique user ID and a group ID to ensure the users are isolated. Some operations require special privileges and are only allowed to be executed by the root user this is called superuser mode and can be accessed by the sudo command. Distributed systems Distributed systems refer to a group of computers working together as a unified computing resource. These systems often run on separate machines that are physically located in different locations, but they work together to perform tasks. They are designed to handle high levels of redundancy and replication to ensure data is always available, even in the event of a failure in part of the system. Distributed systems can be complex to manage due to issues like network latency, fault tolerance, and security concerns. However, they offer benefits in terms of scalability, performance, and reliability.\nFunctions / interfaces of an operating system GUI CLI API Batch files System calls System calls are the interface between the user-level applications and the kernel. They provide a way for programs to request services from the operating system such as file operations, process control, networking, device manipulation, and more. System calls allow user-level software to interact with hardware and system resources in a secure and controlled manner. They are crucial for the functioning of an operating system as they form the bridge between software and hardware.\nHow are system calls used System calls are used in a program when a process in user space requires resources or services from the kernel. This could be for operations such as creating processes, reading from or writing to files, communicating over network, accessing system clocks, etc.\nThe first input that the program will need is the names of the two files: the input file and the output file. These names can be specified in many ways, depending on the operating-system design. One approach is for the program to ask the user for the names of the two files. In an interactive system, this approach will require a sequence of system calls, first to write a prompting message on the screen and then to read from the keyboard the characters that define the two files. On mouse-based and icon-based systems, a menu of file names is usually displayed in a window. The user can then use the mouse to select the source name, and a window can be opened for the destination name to be specified. File systems The linux file system is a tree structure with the root directory at the top. The root directory is denoted by /. The directories are separated by / and the files are separated by .. The file system is case sensitive. The file system is made up of the following:\n1 2 bin dev home lib lib64 lost+found mnt proc run snap sys usr boot etc init lib32 libx32 media opt root sbin srv tmp var The bin folder comtains the binaries of the programs. The etc folder contains the configuration files. The home folder contains the user files. The lib folder contains the libraries. The root folder contains the root user files. The sbin folder contains the system binaries. The tmp folder contains the temporary files. The var folder contains the variable files. The home folder contains the user files. Everything a user executes is stored in the subfolders of the home folder. When the user creates an account on the linux operation system a new folder gets created in the home folder that contains all the information of the user.\nConnect devices may be mounted in the /media directory, and can be found out by the lsblk command. File management ls: running this commmand will list all the files stored in the current directory or folder ls -a: running this commmand will list all the files stored in the current directory or folder plus the hidden files cd: change directory command will help you traverse through the file system. Running cd as a standalone command will take you to the home directory. Running cd .. will take you to the parent directory. Running cd will take you to the folder name. Running cd / will take you to the root directory. pwd: running this command will print the current working directory mkdir : running this command will create a new directory touch : running this command will create a new file rm : running this command will remove the file rm -r : running this command will remove the folder rm -rf : running this command will remove the folder and all the files in it including the hidden files mv : running this command will move the file, if the path is same then it will rename the file. cp : running this command will copy the file cp -r : running this command will copy the folder cat : running this command will print the contents of the file cat \u003e : running this command will copy the contents of the first file to the second file cat \u003e\u003e : running this command will append the contents of the first file to the second file cat | grep : running this command will print the lines of the file that contain the string cat | grep -v : running this command will print the lines of the file that do not contain the string cat | grep -i : running this command will print the lines of the file that contain the string irrespective of the case cat | grep -n : running this command will print the lines of the file that contain the string along with the line number df and df -h can be used to check the occupied storage by the file system Important commands to remember man: running the man as the prefix to any command will give you the documentation of the whole binary/command -h or --help: running any one of these commnds will give a short listing of the package -v or --version: running any of of these commands will display the version of software you are using. This command is typically used to verify the installation of packages. Installation of packages Apps or packages can be installed in the system via the apt or the apt-get command. Here are the key things to remember.\nThere is a pool where all the system binaries are stored These system binaries need to be updated via the following command before installation of every program 1 sudo apt update Binares and packages can be updated in the system by running this command 1 sudo apt upgrade Packages can be installed by this command 1 sudo apt install Packages can be removed by this command 1 sudo apt remove --purge and then removing any unused dependencies by running this command 1 sudo apt autoremove Packages can be searched by this command 1 sudo apt search Processes When a linux operating system is run then many processes are created, these usually run at the user level rather running at the kernal level. Processes can be run via the ps\n1 ps Output\n1 2 3 PID TTY TIME CMD 372 pts/0 00:00:00 zsh 470 pts/0 00:00:00 ps An alternative to running the ps command is running the top or htop command. Htop is not natively installed in many systems and can be installed via sudo apt install htop in debian based systems.\nTo see every process on the system\n1 ps -e Deadlocks A deadlock is a situation in which two computer programs sharing the same resource are effectively preventing each other from accessing the resource, resulting in both programs ceasing to function. The earliest computer operating systems ran only one program at a time. All of the resources of the system were available to this one program. Later, operating systems ran multiple programs at once, interleaving them. Programs would often request resources in a specific order. If a program requested resource A and later requested resource B, another program would be able to run in between and use resource B, but not A, since it had not yet been released. If the first program then requested resource B, it would be locked out forever, since the other program had locked B and was waiting for A. This was the first and simplest sort of deadlock. Deadlocks can occur in operating systems, parallel computing, and distributed systems, as well as in everyday life.\nSafe state In the context of operating systems, a safe state is a state where the system can allocate resources to each process in some order and avoid a deadlock. In other words, a system is in a safe state if there exists a sequence (called a safe sequence) in which each process can request and be allocated all its remaining required resources, execute to completion, release all its allocated resources, and still ensure that every other process can similarly complete. If no such sequence exists, the system is said to be in an unsafe state. It’s important to note that being in an unsafe state does not imply that deadlock is inevitable, but it does mean that the risk of deadlock is present.\nSafe, unsafe, deadlock state resource allocation graph scheme Algorithms Banker’s algorithm Let n = number of processes, and m = number of resources types\nAvailable: Vecotor of length m. If available [j] = k, there are k instances of resource type Rj available. Max: n x m matrix. If Max [i,j] = k, then process Pi may request at most k instances of resource type Rj. Allocation: n x m matrix. If Allocation [i,j] = k then Pi is currently allocated k instances of Rj. Need: n x m matrix. If Need [i,j] = k, then Pi may need k more instances of Rj to complete its task. Need [i,j] = Max [i,j] - Allocation [i,j] Safety algorithm (banker’s algorithm) Let work and finish be vectors of length m and n, respectively Initialize: Work = Available Finish [i] = false for i = 0, 1, …, n-1 Find an i such that both Finish [i] = false Need \u003c Work If no such i exists, go to step 4 Work = Wirj + Allocation Finish [i] = true go to step 2 If finish [i] == true for all i, then the system is in a safe state Example Work = Available Work = 3 3 2 Finish [i] = false for i = 0, 1, 2, 3, 4\nFinish [p0] = false Need [p0] \u003c= Work 7 4 3 \u003c= 3 3 2 (false) Finish [p1] = false Need [p1] \u003c= Work 1 2 2 \u003c= 3 3 2 (true) Work = Work + Allocation [p1] 3 3 2 + 2 0 0 = 5 3 2 Work = 5 3 2\t5 5 Finish [p1] = true - 1\tFinish [p2] = false\tNeed [p2] \u003c= Work\t6 0 0 \u003c= 5 3 2 (true)\tFinish [p3] = false\tNeed [p3] \u003c= Work\t0 1 1 \u003c= 5 3 2 (true)\tWork = Work + Allocation [p3] 5 3 2 + 2 1 1 = 7 4 3 Finish [p3] = true - 2 5 5 Finish [p0] = false\tneed [p0] \u003c= Work\t4 3 1 \u003c= 7 4 3 (true)\tWork = Work + Allocation [p0]\t7 4 3 + 0 0 2 = 7 4 5\tFinish [p0] = true - 3\t5 5 Finish [p2] = false\tNeed [p2] \u003c= Work\t7 4 3 \u003c 7 4 5 (true)\tWork = Work + Allocation [p2]\t7 4 5 + 0 1 0 = 7 5 5\tFinish [p2] = true - 4\t5 5 Finish [p4] = false\tNeed [p4] \u003c= Work\t6 0 0 \u003c= 7 5 5 (true)\tWork = Work + Allocation [p4]\t7 5 5 + 3 0 2 = 10 5 7\tFinish [p4] = true - 5\t5 5 Resource request algorithm (banker’s algorithm) Request = request vector for process Pi. If request [j] = k, then process Pi wants k instances of resource type Rj.\nIf request [i] \u003c= Need [i], go to step 2. Otherwise, raise an error condition, since the process has exceeded its maximum claim.\nIf request [i] \u003c= Available, go to step 3. Otherwise, Pi must wait, since the resources are not available.\nHave the system pretend to have allocated the requested resources to process Pi by modifying the state as follows: Available = Available - request [i] Allocation [i] = Allocation [i] + request [i] Need [i] = Need [i] - request [i]\nIf safe -\u003e the resources are allocated to Pi If unsafe -\u003e Pi must wait, and the old resource-allocation state is restored Example Consider the following snapshot of a system:\nAllocation Need Available Answer the following questions using banker’s algo\nWhat is the content of the matrix Need? Need = Max - Allocation A B C D 0 | | | | | 1 | | | | | 2 | | | | | 3 | | | | | 4 | | | | | Work = 1 5 2 0 Finish [i] = false Need [p0] \u003c= Work 0 0 0 0 \u003c= 1 5 2 0 (true) Finish [p0] = true 5 5 Finish [p1] = false Nedd [p1] \u003c= Work 0 7 5 0 \u003c= 1 5 3 2 (false) Finish [p2] = false 1 0 0 2 \u003c= 1 5 3 2 (true) Work = Work + Allocation [p2] 1 5 2 0 + 1 0 0 2 = 2 5 2 2 Finish [p2] = true 5 5 Finish [p3] = false 0 0 2 0 \u003c= 2 5 2 2 (true) Work = Work + Allocation [p3] 2 5 2 2 + 0 0 2 0 = 2 5 4 2 Finish [p3] = true 5 5 Finish [p4] = false 0 6 4 6 \u003c= 2 5 4 2 (true) Work = Work + Allocation [p4] 2 5 4 2 + 0 6 4 6 = 2 11 8 8 Finish [p4] = true 5 5 Finish [p1] = false 0 7 5 0 \u003c= 2 11 8 8 (true) Work = Work + Allocation [p1] 2 11 8 8 + 0 7 5 0 = 2 18 13 8 Finish [p1] = true \\\nIs the system in a safe state? If yes then give the safety sequence. If a request from process P1 arrives for (0, 4, 2, 0), can the request be granted immediately? Producer consumer problem Producer process\nProduces information Puts information in buffer Consumer process\nConsumes information Takes information out of buffer Buffer\nShared data structure Size of buffer is fixed Producer must wait if buffer is full Consumer must wait if buffer is empty Code for producer process\n1 2 3 4 5 6 7 while (true) { /* produce an item in next_produced */ while (((in + 1) % BUFFER_SIZE) == out) /* do nothing */ buffer [in] = next_produced; in = (in + 1) % BUFFER_SIZE; } Race condition: A race condition in operating systems occurs when the behavior of a system or program depends on the relative timing or interleaving of multiple concurrent operations. It can lead to unpredictable and undesired outcomes, such as incorrect results, crashes, or deadlock. Race conditions typically arise when multiple threads or processes access shared resources or variables without proper synchronization mechanisms. Critical section problem Consider a system with n processes, each of which has a segment of code called a critical section, in which the process may be changing common variables, updating a table, writing a file, and so on. The important feature of the system is that, when one process is executing in its critical section, no other process is to be allowed to execute in its critical section. The critical-section problem is to design a protocol that the processes can use to cooperate. Each process must request permission to enter its critical section. The section of code implementing this request is the entry section. The critical section may be followed by an exit section. The remaining code is the remainder section. General structure of process P1 1 2 3 4 5 6 do { /* entry section */ /* critical section */ /* exit section */ /* remainder section */ } while (true); Solution to critical-section-problem Mutual exclusion If process Pi is executing in its critical section, then no other processes can be executing in their critical sections Progress If no process is executing in its critical section and there exist some processes that wish to enter their critical section, then the selection of the processes that will enter the critical section next cannot be postponed indefinitely Bounded waiting A bound must exist on the number of times that other processes are allowed to enter their critical sections after a process has made a request to enter its critical section and before that request is granted ","wordCount":"3533","inLanguage":"en","datePublished":"2023-11-23T12:52:03+05:30","dateModified":"2023-11-23T12:52:03+05:30","author":{"@type":"Person","name":"Aum Pauskar"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://aumpauskar.github.io/blog/posts/os/linux/"},"publisher":{"@type":"Organization","name":"Aum's blogging site","logo":{"@type":"ImageObject","url":"https://aumpauskar.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://aumpauskar.github.io/blog/ accesskey=h title="Aum's blogging site (Alt + H)">Aum's blogging site</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://aumpauskar.github.io/blog/>Home</a>&nbsp;»&nbsp;<a href=https://aumpauskar.github.io/blog/posts/>Posts</a></div><h1 class=post-title>Linux</h1><div class=post-meta><span title='2023-11-23 12:52:03 +0530 IST'>November 23, 2023</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;3533 words&nbsp;·&nbsp;Aum Pauskar</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#bases-of-an-operating-system>Bases of an operating system</a><ul><li><a href=#use-of-an-operating-system>Use of an operating system</a></li><li><a href=#kernel>Kernel</a></li><li><a href=#dual-mode-operation-of-the-operating-system>Dual mode operation of the operating system</a></li><li><a href=#process-management>Process management</a></li><li><a href=#memory-management>Memory management</a></li><li><a href=#cpu-scheduling>CPU scheduling</a></li><li><a href=#storage-management>Storage management</a></li><li><a href=#protection>Protection</a></li><li><a href=#distributed-systems>Distributed systems</a></li><li><a href=#functions--interfaces-of-an-operating-system>Functions / interfaces of an operating system</a></li><li><a href=#system-calls>System calls</a></li></ul></li><li><a href=#file-systems>File systems</a><ul><li><a href=#file-management>File management</a></li></ul></li><li><a href=#important-commands-to-remember>Important commands to remember</a></li><li><a href=#installation-of-packages>Installation of packages</a></li><li><a href=#processes>Processes</a></li><li><a href=#deadlocks>Deadlocks</a></li><li><a href=#safe-state>Safe state</a><ul><li><a href=#safe-unsafe-deadlock-state>Safe, unsafe, deadlock state</a></li></ul></li><li><a href=#algorithms>Algorithms</a><ul><li><a href=#bankers-algorithm>Banker&rsquo;s algorithm</a></li><li><a href=#safety-algorithm-bankers-algorithm>Safety algorithm (banker&rsquo;s algorithm)</a></li><li><a href=#resource-request-algorithm-bankers-algorithm>Resource request algorithm (banker&rsquo;s algorithm)</a></li><li><a href=#example-1>Example</a></li><li><a href=#producer-consumer-problem>Producer consumer problem</a></li><li><a href=#critical-section-problem>Critical section problem</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h1 id=linuxunix-shell-commands>Linux/UNIX shell commands<a hidden class=anchor aria-hidden=true href=#linuxunix-shell-commands>#</a></h1><p>The UNIX shell is a command-line interface made for interacting with the OS. There are various commands to execute this.</p><p><strong>Note:</strong> The current documentaiton is based on <strong>Ububtu</strong> and similar debian bases operating systems.</p><h2 id=bases-of-an-operating-system>Bases of an operating system<a hidden class=anchor aria-hidden=true href=#bases-of-an-operating-system>#</a></h2><ul><li>Execute user programs and make solving user problems easier</li><li>Make the computer system convenient to use</li><li>Use the computer hardware in an efficient manner</li></ul><p>A computer system can be divided roughly into four components: the <strong>hardware</strong>, the <strong>operating system</strong>, the <strong>application programs</strong>, and the <strong>users</strong>.</p><h3 id=use-of-an-operating-system>Use of an operating system<a hidden class=anchor aria-hidden=true href=#use-of-an-operating-system>#</a></h3><ul><li>The operating system is responsible for the following activities in connection with process management<ul><li>Process creation and deletion</li><li>Process suspension and resumption</li><li>Provision of mechanisms for process synchronization</li><li>Provision of mechanisms for process communication</li><li>Provision of mechanisms for deadlock handling</li></ul></li></ul><p>Operating systems is a <strong>resource allocator</strong> and it is a <strong>control program</strong>.</p><h3 id=kernel>Kernel<a hidden class=anchor aria-hidden=true href=#kernel>#</a></h3><p>The kernel is the one program running at all times on the computer. It is the core of the operating system. It performs the following functions:</p><ul><li>It is a program that remains in the memory at all times and is responsible for all the major activities of the operating system</li><li>It is the first program to be loaded into the memory after the booting process is completed</li><li>It is the last program to be removed from the memory when the computer is shut down</li><li>Other programs are classified into two categories: <strong>system programs</strong> and <strong>application programs</strong></li></ul><h3 id=dual-mode-operation-of-the-operating-system>Dual mode operation of the operating system<a hidden class=anchor aria-hidden=true href=#dual-mode-operation-of-the-operating-system>#</a></h3><p>In layman terms, the modern operating systems have two modes to run on, user mode and kernel mode. In general there are certain privalages being placed on certain programs that may only run in the kernel mode. Some computers even come with a VMM (virtual machine manager) for running guest opearting systems.</p><h3 id=process-management>Process management<a hidden class=anchor aria-hidden=true href=#process-management>#</a></h3><ul><li>Process creation and deletion</li><li>Process suspension and resumption</li><li>Provision of mechanisms for process synchronization</li><li>Provision of mechanisms for process communication</li><li>Provision of mechanisms for deadlock handling</li></ul><h3 id=memory-management>Memory management<a hidden class=anchor aria-hidden=true href=#memory-management>#</a></h3><p>The job of a memory management software is to manage all process within a certain limitations of the memmory allowed by the computer&rsquo;s hardware specifications. The memory management software is responsible for the following:</p><ul><li>Keeping track of which parts of memory are currently being used and by whom</li><li>Deciding which processes (or parts thereof) and data to move into and out of memory</li><li>Allocating and deallocating memory space as needed</li><li>(Optional) Swapping between the main memory and the secondary memory</li></ul><h3 id=cpu-scheduling>CPU scheduling<a hidden class=anchor aria-hidden=true href=#cpu-scheduling>#</a></h3><p>The job of a CPU scheduling software is to manage all process within a certain limitations of the CPU allowed by the computer&rsquo;s hardware specifications. The CPU scheduling software is responsible for the following:</p><ul><li>Deciding which process to run next</li><li>Deciding when to allocate and deallocate CPU to a process</li><li>Deciding when to suspend and resume a process</li><li>Deciding which process to move into and out of memory</li><li>Deciding which process to move into and out of the secondary memory</li></ul><h3 id=storage-management>Storage management<a hidden class=anchor aria-hidden=true href=#storage-management>#</a></h3><p>The job of a storage management software is to manage all process within a certain limitations of the storage allowed by the computer&rsquo;s hardware specifications. The storage management software is responsible for the following:</p><ul><li>A storage management system is responsible to keep track of the status of each storage unit, whether it is allocated or free</li><li>Memory management is a part of storage management</li><li>Modern operating systems use a file system to manage the secondary storage</li><li>The file system might be FAT, NTFS, ext4, etc.</li><li>In case of a file system, the computer has a table contatining the location of all the memory blocks that are free and the ones that are occupied</li><li>The storage management system is also reponsible for running data across various data blocks in SSDs to increase hardware lifespan.</li><li>Various storage devices<ul><li>Ragisters</li><li>Cache</li><li>(DDR) RAM</li><li>SSD / HDD</li></ul></li></ul><h3 id=protection>Protection<a hidden class=anchor aria-hidden=true href=#protection>#</a></h3><ul><li>The operating system must ensure that the access to the resources is controlled and to ensure the isolation of the various processes</li><li>The operating system must also ensure that the computer is safe from any external attacks and viruses</li><li>In operating systems like Linux, the user is given a unique user ID and a group ID to ensure the users are isolated.</li><li>Some operations require special privileges and are only allowed to be executed by the root user this is called superuser mode and can be accessed by the <code>sudo</code> command.</li></ul><h3 id=distributed-systems>Distributed systems<a hidden class=anchor aria-hidden=true href=#distributed-systems>#</a></h3><p>Distributed systems refer to a group of computers working together as a unified computing resource. These systems often run on separate machines that are physically located in different locations, but they work together to perform tasks. They are designed to handle high levels of redundancy and replication to ensure data is always available, even in the event of a failure in part of the system. Distributed systems can be complex to manage due to issues like network latency, fault tolerance, and security concerns. However, they offer benefits in terms of scalability, performance, and reliability.</p><h3 id=functions--interfaces-of-an-operating-system>Functions / interfaces of an operating system<a hidden class=anchor aria-hidden=true href=#functions--interfaces-of-an-operating-system>#</a></h3><ul><li>GUI</li><li>CLI</li><li>API</li><li>Batch files</li></ul><h3 id=system-calls>System calls<a hidden class=anchor aria-hidden=true href=#system-calls>#</a></h3><p>System calls are the interface between the user-level applications and the kernel. They provide a way for programs to request services from the operating system such as file operations, process control, networking, device manipulation, and more. System calls allow user-level software to interact with hardware and system resources in a secure and controlled manner. They are crucial for the functioning of an operating system as they form the bridge between software and hardware.</p><ul><li><p>How are system calls used<br>System calls are used in a program when a process in user space requires resources or services from the kernel. This could be for operations such as creating processes, reading from or writing to files, communicating over network, accessing system clocks, etc.</p><ul><li>The first input that the program will need is the names of the two files: the input file and the output file. These names can be specified in many ways, depending on the operating-system design.</li><li>One approach is for the program to ask the user for the names of the two files.</li><li>In an interactive system, this approach will require a sequence of system calls, first to write a prompting message on the screen and then to read from the keyboard the characters that define the two files.</li><li>On mouse-based and icon-based systems, a menu of file names is usually displayed in a window. The user can then use the mouse to select the source name, and a window can be opened for the destination name to be specified.</li></ul></li></ul><h2 id=file-systems>File systems<a hidden class=anchor aria-hidden=true href=#file-systems>#</a></h2><p>The linux file system is a tree structure with the root directory at the top. The root directory is denoted by <code>/</code>. The directories are separated by <code>/</code> and the files are separated by <code>.</code>. The file system is case sensitive. The file system is made up of the following:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>bin   dev  home  lib    lib64   lost+found  mnt  proc  run   snap  sys  usr
</span></span><span class=line><span class=cl>boot  etc  init  lib32  libx32  media       opt  root  sbin  srv   tmp  var
</span></span></code></pre></td></tr></table></div></div><p>The bin folder comtains the binaries of the programs. The etc folder contains the configuration files. The home folder contains the user files. The lib folder contains the libraries. The root folder contains the root user files. The sbin folder contains the system binaries. The tmp folder contains the temporary files. The var folder contains the variable files. The home folder contains the user files. Everything a user executes is stored in the subfolders of the home folder. When the user creates an account on the linux operation system a new folder gets created in the home folder that contains all the information of the user.</p><ul><li>Connect devices may be mounted in the /media directory, and can be found out by the <code>lsblk</code> command.</li></ul><h3 id=file-management>File management<a hidden class=anchor aria-hidden=true href=#file-management>#</a></h3><ul><li><code>ls</code>: running this commmand will list all the files stored in the current directory or folder</li><li><code>ls -a</code>: running this commmand will list all the files stored in the current directory or folder plus the hidden files</li><li><code>cd</code>: change directory command will help you traverse through the file system. Running cd as a standalone command will take you to the home directory. Running <code>cd ..</code> will take you to the parent directory. Running <code>cd &lt;folder name></code> will take you to the folder name. Running <code>cd /</code> will take you to the root directory.</li><li><code>pwd</code>: running this command will print the current working directory</li><li><code>mkdir &lt;foldername></code>: running this command will create a new directory</li><li><code>touch &lt;filename.fileextension></code>: running this command will create a new file</li><li><code>rm &lt;filename.fileextension></code>: running this command will remove the file</li><li><code>rm -r &lt;foldername></code>: running this command will remove the folder</li><li><code>rm -rf &lt;foldername></code>: running this command will remove the folder and all the files in it including the hidden files</li><li><code>mv &lt;path/file> &lt;path/file></code>: running this command will move the file, if the path is same then it will rename the file.</li><li><code>cp &lt;path/file> &lt;path/file></code>: running this command will copy the file</li><li><code>cp -r &lt;path/folder> &lt;path/folder></code>: running this command will copy the folder</li><li><code>cat &lt;file></code>: running this command will print the contents of the file<ul><li><code>cat &lt;file> > &lt;file></code>: running this command will copy the contents of the first file to the second file</li><li><code>cat &lt;file> >> &lt;file></code>: running this command will append the contents of the first file to the second file</li><li><code>cat &lt;file> | grep &lt;string></code>: running this command will print the lines of the file that contain the string</li><li><code>cat &lt;file> | grep -v &lt;string></code>: running this command will print the lines of the file that do not contain the string</li><li><code>cat &lt;file> | grep -i &lt;string></code>: running this command will print the lines of the file that contain the string irrespective of the case</li><li><code>cat &lt;file> | grep -n &lt;string></code>: running this command will print the lines of the file that contain the string along with the line number</li></ul></li><li><code>df</code> and <code>df -h</code> can be used to check the occupied storage by the file system</li></ul><h2 id=important-commands-to-remember>Important commands to remember<a hidden class=anchor aria-hidden=true href=#important-commands-to-remember>#</a></h2><ul><li><code>man</code>: running the <code>man</code> as the prefix to any command will give you the documentation of the whole binary/command</li><li><code>-h</code> or <code>--help</code>: running any one of these commnds will give a short listing of the package</li><li><code>-v</code> or <code>--version</code>: running any of of these commands will display the version of software you are using. This command is typically used to verify the installation of packages.</li></ul><h2 id=installation-of-packages>Installation of packages<a hidden class=anchor aria-hidden=true href=#installation-of-packages>#</a></h2><p>Apps or packages can be installed in the system via the <code>apt</code> or the <code>apt-get</code> command. Here are the key things to remember.</p><ul><li>There is a pool where all the system binaries are stored</li><li>These system binaries need to be updated via the following command before installation of every program<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo apt update
</span></span></code></pre></td></tr></table></div></div></li><li>Binares and packages can be updated in the system by running this command<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo apt upgrade
</span></span></code></pre></td></tr></table></div></div></li><li>Packages can be installed by this command<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo apt install &lt;package name&gt;
</span></span></code></pre></td></tr></table></div></div></li><li>Packages can be removed by this command<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo apt remove --purge &lt;package name&gt;
</span></span></code></pre></td></tr></table></div></div>and then removing any unused dependencies by running this command<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo apt autoremove
</span></span></code></pre></td></tr></table></div></div></li><li>Packages can be searched by this command<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo apt search &lt;package name&gt;
</span></span></code></pre></td></tr></table></div></div></li></ul><h2 id=processes>Processes<a hidden class=anchor aria-hidden=true href=#processes>#</a></h2><p>When a linux operating system is run then many processes are created, these usually run at the user level rather running at the kernal level.<br>Processes can be run via the <code>ps</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>ps
</span></span></code></pre></td></tr></table></div></div><p>Output</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2>2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>    PID TTY          TIME CMD
</span></span><span class=line><span class=cl>    372 pts/0    00:00:00 zsh
</span></span><span class=line><span class=cl>    470 pts/0    00:00:00 ps
</span></span></code></pre></td></tr></table></div></div><p>An alternative to running the ps command is running the <code>top</code> or <code>htop</code> command. Htop is not natively installed in many systems and can be installed via <code>sudo apt install htop</code> in debian based systems.<br>To see every process on the system</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>ps -e
</span></span></code></pre></td></tr></table></div></div><h2 id=deadlocks>Deadlocks<a hidden class=anchor aria-hidden=true href=#deadlocks>#</a></h2><p>A deadlock is a situation in which two computer programs sharing the same resource are effectively preventing each other from accessing the resource, resulting in both programs ceasing to function. The earliest computer operating systems ran only one program at a time. All of the resources of the system were available to this one program. Later, operating systems ran multiple programs at once, interleaving them. Programs would often request resources in a specific order. If a program requested resource A and later requested resource B, another program would be able to run in between and use resource B, but not A, since it had not yet been released. If the first program then requested resource B, it would be locked out forever, since the other program had locked B and was waiting for A. This was the first and simplest sort of deadlock. Deadlocks can occur in operating systems, parallel computing, and distributed systems, as well as in everyday life.</p><h2 id=safe-state>Safe state<a hidden class=anchor aria-hidden=true href=#safe-state>#</a></h2><p>In the context of operating systems, a safe state is a state where the system can allocate resources to each process in some order and avoid a deadlock. In other words, a system is in a safe state if there exists a sequence (called a safe sequence) in which each process can request and be allocated all its remaining required resources, execute to completion, release all its allocated resources, and still ensure that every other process can similarly complete. If no such sequence exists, the system is said to be in an unsafe state. It&rsquo;s important to note that being in an unsafe state does not imply that deadlock is inevitable, but it does mean that the risk of deadlock is present.</p><h3 id=safe-unsafe-deadlock-state>Safe, unsafe, deadlock state<a hidden class=anchor aria-hidden=true href=#safe-unsafe-deadlock-state>#</a></h3><ul><li>resource allocation graph scheme</li></ul><h2 id=algorithms>Algorithms<a hidden class=anchor aria-hidden=true href=#algorithms>#</a></h2><h3 id=bankers-algorithm>Banker&rsquo;s algorithm<a hidden class=anchor aria-hidden=true href=#bankers-algorithm>#</a></h3><p>Let n = number of processes, and m = number of resources types</p><ul><li>Available: Vecotor of length m. If available [j] = k, there are k instances of resource type Rj available.</li><li>Max: n x m matrix. If Max [i,j] = k, then process Pi may request at most k instances of resource type Rj.</li><li>Allocation: n x m matrix. If Allocation [i,j] = k then Pi is currently allocated k instances of Rj.</li><li>Need: n x m matrix. If Need [i,j] = k, then Pi may need k more instances of Rj to complete its task.</li><li>Need [i,j] = Max [i,j] - Allocation [i,j]</li></ul><h3 id=safety-algorithm-bankers-algorithm>Safety algorithm (banker&rsquo;s algorithm)<a hidden class=anchor aria-hidden=true href=#safety-algorithm-bankers-algorithm>#</a></h3><ul><li>Let work and finish be vectors of length m and n, respectively
Initialize:
Work = Available
Finish [i] = false for i = 0, 1, &mldr;, n-1</li><li>Find an i such that both<ul><li>Finish [i] = false</li><li>Need &lt; Work
If no such i exists, go to step 4</li></ul></li><li>Work = Wirj + Allocation
Finish [i] = true
go to step 2</li><li>If finish [i] == true for all i, then the system is in a safe state</li></ul><h4 id=example>Example<a hidden class=anchor aria-hidden=true href=#example>#</a></h4><ol><li><p>Work = Available<br>Work = 3 3 2<br>Finish [i] = false for i = 0, 1, 2, 3, 4</p></li><li><p>Finish [p0] = false<br>Need [p0] &lt;= Work<br>7 4 3 &lt;= 3 3 2 (false)<br>Finish [p1] = false<br>Need [p1] &lt;= Work<br>1 2 2 &lt;= 3 3 2 (true)<br>Work = Work + Allocation [p1]<br>3 3 2 + 2 0 0 = 5 3 2<br>Work = 5 3 2<br>5 5<br><strong>Finish [p1] = true</strong> - 1<br><strong>Finish [p2] = false</strong><br>Need [p2] &lt;= Work<br>6 0 0 &lt;= 5 3 2 (true)<br>Finish [p3] = false<br>Need [p3] &lt;= Work<br>0 1 1 &lt;= 5 3 2 (true)<br>Work = Work + Allocation [p3]<br>5 3 2 + 2 1 1 = 7 4 3<br><strong>Finish [p3] = true</strong> - 2<br>5 5<br>Finish [p0] = false<br>need [p0] &lt;= Work<br>4 3 1 &lt;= 7 4 3 (true)<br>Work = Work + Allocation [p0]<br>7 4 3 + 0 0 2 = 7 4 5<br><strong>Finish [p0] = true</strong> - 3<br>5 5<br>Finish [p2] = false<br>Need [p2] &lt;= Work<br>7 4 3 &lt; 7 4 5 (true)<br>Work = Work + Allocation [p2]<br>7 4 5 + 0 1 0 = 7 5 5<br><strong>Finish [p2] = true</strong> - 4<br>5 5<br>Finish [p4] = false<br>Need [p4] &lt;= Work<br>6 0 0 &lt;= 7 5 5 (true)<br>Work = Work + Allocation [p4]<br>7 5 5 + 3 0 2 = 10 5 7<br><strong>Finish [p4] = true</strong> - 5<br>5 5</p></li></ol><h3 id=resource-request-algorithm-bankers-algorithm>Resource request algorithm (banker&rsquo;s algorithm)<a hidden class=anchor aria-hidden=true href=#resource-request-algorithm-bankers-algorithm>#</a></h3><p>Request = request vector for process Pi. If request [j] = k, then process Pi wants k instances of resource type Rj.</p><ol><li><p>If request [i] &lt;= Need [i], go to step 2. Otherwise, raise an error condition, since the process has exceeded its maximum claim.</p></li><li><p>If request [i] &lt;= Available, go to step 3. Otherwise, Pi must wait, since the resources are not available.</p></li><li><p>Have the system pretend to have allocated the requested resources to process Pi by modifying the state as follows:
Available = Available - request [i]
Allocation [i] = Allocation [i] + request [i]
Need [i] = Need [i] - request [i]</p><ul><li>If safe -> the resources are allocated to Pi</li><li>If unsafe -> Pi must wait, and the old resource-allocation state is restored</li></ul></li></ol><h3 id=example-1>Example<a hidden class=anchor aria-hidden=true href=#example-1>#</a></h3><p>Consider the following snapshot of a system:</p><table><thead><tr><th></th><th>Allocation</th><th>Need</th><th>Available</th></tr></thead></table><ul><li><p>Answer the following questions using banker&rsquo;s algo</p><ul><li>What is the content of the matrix Need?<br>Need = Max - Allocation</li></ul><table><thead><tr><th></th><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>0 |</td><td>|</td><td>|</td><td>|</td><td>|</td></tr><tr><td>1 |</td><td>|</td><td>|</td><td>|</td><td>|</td></tr><tr><td>2 |</td><td>|</td><td>|</td><td>|</td><td>|</td></tr><tr><td>3 |</td><td>|</td><td>|</td><td>|</td><td>|</td></tr><tr><td>4 |</td><td>|</td><td>|</td><td>|</td><td>|</td></tr></tbody></table><p>Work = 1 5 2 0<br>Finish [i] = false
Need [p0] &lt;= Work<br>0 0 0 0 &lt;= 1 5 2 0 (true)<br>Finish [p0] = true<br>5 5 Finish [p1] = false<br>Nedd [p1] &lt;= Work<br>0 7 5 0 &lt;= 1 5 3 2 (false)<br>Finish [p2] = false<br>1 0 0 2 &lt;= 1 5 3 2 (true)<br>Work = Work + Allocation [p2]<br>1 5 2 0 + 1 0 0 2 = 2 5 2 2<br>Finish [p2] = true<br>5 5<br>Finish [p3] = false<br>0 0 2 0 &lt;= 2 5 2 2 (true)<br>Work = Work + Allocation [p3]<br>2 5 2 2 + 0 0 2 0 = 2 5 4 2<br>Finish [p3] = true<br>5 5<br>Finish [p4] = false<br>0 6 4 6 &lt;= 2 5 4 2 (true)<br>Work = Work + Allocation [p4]<br>2 5 4 2 + 0 6 4 6 = 2 11 8 8<br>Finish [p4] = true<br>5 5<br>Finish [p1] = false<br>0 7 5 0 &lt;= 2 11 8 8 (true)<br>Work = Work + Allocation [p1]<br>2 11 8 8 + 0 7 5 0 = 2 18 13 8<br>Finish [p1] = true \</p><ul><li>Is the system in a safe state? If yes then give the safety sequence.</li><li>If a request from process P1 arrives for (0, 4, 2, 0), can the request be granted immediately?</li></ul></li></ul><h3 id=producer-consumer-problem>Producer consumer problem<a hidden class=anchor aria-hidden=true href=#producer-consumer-problem>#</a></h3><ul><li><p>Producer process</p><ul><li>Produces information</li><li>Puts information in buffer</li></ul></li><li><p>Consumer process</p><ul><li>Consumes information</li><li>Takes information out of buffer</li></ul></li><li><p>Buffer</p><ul><li>Shared data structure</li><li>Size of buffer is fixed</li><li>Producer must wait if buffer is full</li><li>Consumer must wait if buffer is empty</li></ul></li><li><p>Code for producer process</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1>1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2>2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3>3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4>4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5>5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6>6</a>
</span><span class=lnt id=hl-10-7><a class=lnlinks href=#hl-10-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* produce an item in next_produced */</span>
</span></span><span class=line><span class=cl>	<span class=k>while</span> <span class=p>(((</span><span class=n>in</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=n>BUFFER_SIZE</span><span class=p>)</span> <span class=o>==</span> <span class=n>out</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=cm>/* do nothing */</span>
</span></span><span class=line><span class=cl>	<span class=n>buffer</span> <span class=p>[</span><span class=n>in</span><span class=p>]</span> <span class=o>=</span> <span class=n>next_produced</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>in</span> <span class=o>=</span> <span class=p>(</span><span class=n>in</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=n>BUFFER_SIZE</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>Race condition: A race condition in operating systems occurs when the behavior of a system or program depends on the relative timing or interleaving of multiple concurrent operations. It can lead to unpredictable and undesired outcomes, such as incorrect results, crashes, or deadlock. Race conditions typically arise when multiple threads or processes access shared resources or variables without proper synchronization mechanisms.</li></ul><h3 id=critical-section-problem>Critical section problem<a hidden class=anchor aria-hidden=true href=#critical-section-problem>#</a></h3><ul><li>Consider a system with n processes, each of which has a segment of code called a critical section, in which the process may be changing common variables, updating a table, writing a file, and so on.</li><li>The important feature of the system is that, when one process is executing in its critical section, no other process is to be allowed to execute in its critical section.</li><li>The critical-section problem is to design a protocol that the processes can use to cooperate. Each process must request permission to enter its critical section. The section of code implementing this request is the entry section. The critical section may be followed by an exit section. The remaining code is the remainder section.</li><li>General structure of process P1</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1>1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2>2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3>3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4>4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5>5</a>
</span><span class=lnt id=hl-11-6><a class=lnlinks href=#hl-11-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* entry section */</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* critical section */</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* exit section */</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* remainder section */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>Solution to critical-section-problem<ul><li>Mutual exclusion<ul><li>If process Pi is executing in its critical section, then no other processes can be executing in their critical sections</li></ul></li><li>Progress<ul><li>If no process is executing in its critical section and there exist some processes that wish to enter their critical section, then the selection of the processes that will enter the critical section next cannot be postponed indefinitely</li></ul></li><li>Bounded waiting<ul><li>A bound must exist on the number of times that other processes are allowed to enter their critical sections after a process has made a request to enter its critical section and before that request is granted</li></ul></li></ul></li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://aumpauskar.github.io/blog/posts/python/python_oops/><span class=title>« Prev</span><br><span>OOPS with Python and packages</span>
</a><a class=next href=https://aumpauskar.github.io/blog/posts/computer_network/cn/><span class=title>Next »</span><br><span>Computer networks</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Linux on x" href="https://x.com/intent/tweet/?text=Linux&amp;url=https%3a%2f%2faumpauskar.github.io%2fblog%2fposts%2fos%2flinux%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Linux on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2faumpauskar.github.io%2fblog%2fposts%2fos%2flinux%2f&amp;title=Linux&amp;summary=Linux&amp;source=https%3a%2f%2faumpauskar.github.io%2fblog%2fposts%2fos%2flinux%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Linux on reddit" href="https://reddit.com/submit?url=https%3a%2f%2faumpauskar.github.io%2fblog%2fposts%2fos%2flinux%2f&title=Linux"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Linux on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2faumpauskar.github.io%2fblog%2fposts%2fos%2flinux%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Linux on whatsapp" href="https://api.whatsapp.com/send?text=Linux%20-%20https%3a%2f%2faumpauskar.github.io%2fblog%2fposts%2fos%2flinux%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Linux on telegram" href="https://telegram.me/share/url?text=Linux&amp;url=https%3a%2f%2faumpauskar.github.io%2fblog%2fposts%2fos%2flinux%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Linux on ycombinator" href="https://news.ycombinator.com/submitlink?t=Linux&u=https%3a%2f%2faumpauskar.github.io%2fblog%2fposts%2fos%2flinux%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://aumpauskar.github.io/blog/>Aum's blogging site</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>